{
  "hash": "38ac64d46cdd2884673d65b8612aa083",
  "result": {
    "engine": "knitr",
    "markdown": "# Column-wise Operations in dplyr\n\n<!--\nHidden comments placeholder\n---------------------------\n\nTo preview:\nbookdown::preview_chapter(\"chapters/07_part_repeated_operations/03_dplyr_column_wise.Rmd\")\n\nCopy and paste:\nüëÜ**Here's what we did above:**\n-->\n\nThroughout the chapters in this book we have learned to do a really vast array of useful data transformations and statistical analyses with the help of the `dplyr` package.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![dplyr graphic](dplyr.png){width=2.45in}\n:::\n:::\n\n\n\n\n\n\nSo far, however, we've always done these transformations and statistical analyses on one column of our data frame at a time. There isn't anything inherently \"wrong\" with this approach, but, for reasons we've already discussed, there are often advantages to telling R what you want to do one time, and then asking R to do that thing repeatedly *across* all, or a subset of, the columns in your data frame. That is exactly what `dplyr`'s `across()` function allows us to do.\n\nThere are so many ways we might want to use the `across()` function in our R programs. We can't begin to cover, or even imagine, them all. Instead, the goal of this chapter is just to provide you with an overview of the `across()` function and show you some examples of using it with `filter()`, `mutate()`, and `summarise()` to get you thinking about how you might want to use it in your R programs.\n\nBefore we discuss further, let's take a look at a quick example. The first thing we will need to do is load `dplyr`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr, warn.conflicts = FALSE)\n```\n:::\n\n\n\n\n\n\nThen, we will simulate some data. In this case, we are creating a data frame that contains three columns of 10 random numbers:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\ndf_xyz <- tibble(\n  row = 1:10,\n  x   = rnorm(10),\n  y   = rnorm(10),\n  z   = rnorm(10)\n) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 4\n     row       x      y      z\n   <int>   <dbl>  <dbl>  <dbl>\n 1     1 -0.560   1.22  -1.07 \n 2     2 -0.230   0.360 -0.218\n 3     3  1.56    0.401 -1.03 \n 4     4  0.0705  0.111 -0.729\n 5     5  0.129  -0.556 -0.625\n 6     6  1.72    1.79  -1.69 \n 7     7  0.461   0.498  0.838\n 8     8 -1.27   -1.97   0.153\n 9     9 -0.687   0.701 -1.14 \n10    10 -0.446  -0.473  1.25 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nUp to this point, if we wanted to find the mean of each column, we would probably have written code like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  summarise(\n    x_mean = mean(x),\n    y_mean = mean(y),\n    z_mean = mean(y)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n  x_mean y_mean z_mean\n   <dbl>  <dbl>  <dbl>\n1 0.0746  0.209  0.209\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWith the help of the `across()` function, we can now get the mean of each column like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>%\n  summarise(\n    across(\n      .cols  = c(x:z),\n      .fns   = mean,\n      .names = \"{col}_mean\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n  x_mean y_mean z_mean\n   <dbl>  <dbl>  <dbl>\n1 0.0746  0.209 -0.425\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow, you might ask why this is a better approach. Fair question.\n\nIn this case, using `across()` doesn't actually reduce the number of lines of code we wrote. In fact, we wrote two additional lines when we used the `across()` function. However, imagine if we added 20 additional columns to our data frame. Using the first approach, we would have to write 20 additional lines of code inside the `summarise()` function. Using the `across()` approach, we wouldn't have to add any additional code at all. We would simply update the value we pass to the `.cols` argument.\n\nPerhaps *more importantly*, did you notice that we \"accidentally\" forgot to replace `y` with `z` when we copied and pasted `z_mean = mean(y)` in the code chunk for the first approach? If not, go back and take a look. That mistake is fairly easy to catch and fix in this very simple example. But, in real-world projects, mistakes like this are easy to make, and not always so easy to catch. We are much less likely to make similar mistakes when we use `across()`.\n\n## The across() function\n\nThe `across()` function is part of the `dplyr` package. We will always use `across()` *inside* of one of the `dplyr` verbs we've been learning about. Specifically, `mutate()`, and `summarise()`. We will not use `across()` *outside* of the `dplyr` verbs. Additionally, we will always use `across()` within the context of a data frame (as opposed to a vector, matrix, or some other data structure).\n\nTo view the help documentation for `across()`, you can copy and paste `?dplyr::across` into your R console. If you do, you will see that `across()` has four arguments. They are:\n\n1Ô∏è‚É£`.cols`. The value we pass to this argument should be columns of the data frame we want to operate on. We can once again use tidy-select argument modifiers here. In the example above, we used `c(x:z)` to tell R that we wanted to operate on columns x through z (inclusive). If we had also wanted the mean of the `row` column for some reason, we could have used the `everything()` tidy-select modifier to tell R that we wanted to operate on all of the columns in the data frame.\n\n2Ô∏è‚É£`.fns`. This is where you tell `across()` what function, or functions, you want to apply to the columns you selected in `.cols`. In the example above, we passed the mean function to the `.fns` argument. Notice that we typed `mean` without the parentheses (i.e., `mean()`).\n\n3Ô∏è‚É£`...`. In this case, the `...` argument is where we pass any additional arguments to the function we passed to the `.fns` argument. For example, we passed the `mean` function to the `.fns` argument above. In the data frame above, none of the columns had any missing values. Let's go ahead and add some missing values so that we can take a look at how `...` works in `across()`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz$x[2] <- NA_real_\ndf_xyz$y[4] <- NA_real_\ndf_xyz$z[6] <- NA_real_\ndf_xyz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 4\n     row       x      y      z\n   <int>   <dbl>  <dbl>  <dbl>\n 1     1 -0.560   1.22  -1.07 \n 2     2 NA       0.360 -0.218\n 3     3  1.56    0.401 -1.03 \n 4     4  0.0705 NA     -0.729\n 5     5  0.129  -0.556 -0.625\n 6     6  1.72    1.79  NA    \n 7     7  0.461   0.498  0.838\n 8     8 -1.27   -1.97   0.153\n 9     9 -0.687   0.701 -1.14 \n10    10 -0.446  -0.473  1.25 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nAs we've already seen many times, R won't drop the missing values and carry out a complete case analysis by default:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  summarise(\n    x_mean = mean(x),\n    y_mean = mean(y),\n    z_mean = mean(y)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n  x_mean y_mean z_mean\n   <dbl>  <dbl>  <dbl>\n1     NA     NA     NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\nInstead, we have to explicitly tell R to carry out a complete case analysis. We can do so by filtering our rows with missing data (more on this later) or by changing the value of the `mean()` function's `na.rm` argument from `FALSE` (the default) to `TRUE`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  summarise(\n    x_mean = mean(x, na.rm = TRUE),\n    y_mean = mean(y, na.rm = TRUE),\n    z_mean = mean(z, na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n  x_mean y_mean z_mean\n   <dbl>  <dbl>  <dbl>\n1  0.108  0.220 -0.284\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhen we use `across()`, we will need to pass the `na.rm = TRUE` to the `mean()` function in `across()`'s `...` argument like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>%\n  summarise(\n    across(\n      .cols  = everything(),\n      .fns   = mean,\n      na.rm  = TRUE, # Passing na.rm = TRUE to the ... argument\n      .names = \"{col}_mean\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `summarise()`.\ni In argument: `across(.cols = everything(), .fns = mean, na.rm = TRUE, .names\n  = \"{col}_mean\")`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 4\n  row_mean x_mean y_mean z_mean\n     <dbl>  <dbl>  <dbl>  <dbl>\n1      5.5  0.108  0.220 -0.284\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice that we do not actually type out `... =` or anything like that.\n\n4Ô∏è‚É£`.names`. You can use this argument to adjust the column names that will result from the operation you pass to `.fns`. In the example above, we used the special `{cols}` keyword to use each of the column names that were passed to the `.cols` argument as the first part of each of the new columns' names. Then, we asked R to add a literal underscore and the word \"mean\" because these are all mean values. That resulted in the new column names you see above. The default value for `.names` is just `{cols}`. So, if we hadn't modified the value passed to the `.names` argument, our results would have looked like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>%\n  summarise(\n    across(\n      .cols  = everything(),\n      .fns   = mean,\n      na.rm  = TRUE\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 4\n    row     x     y      z\n  <dbl> <dbl> <dbl>  <dbl>\n1   5.5 0.108 0.220 -0.284\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThere is also a special `{fn}` keyword that we can use to pass the name of each of the functions we used in `.fns` as part of the new column names. However, in order to get `{fn}` to work the way we want it to, we have to pass a list of name-function pairs to the `.fns` argument. We'll explain further.\n\nFirst, we will keep the code exactly as it was, but replace \"mean\" with \"{fn}\" in the `.names` argument:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>%\n  summarise(\n    across(\n      .cols  = everything(),\n      .fns   = mean, \n      na.rm  = TRUE,\n      .names = \"{col}_{fn}\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 4\n  row_1   x_1   y_1    z_1\n  <dbl> <dbl> <dbl>  <dbl>\n1   5.5 0.108 0.220 -0.284\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis is not the result we wanted. Because, we didn't *name* the function that we passed to `.fns`, `across()` essentially used \"function number 1\" as its name. In order to get the result we want, we need to pass a list of name-function pairs to the `.fns` argument like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  summarise(\n    across(\n      .cols  = everything(),\n      .fns   = list(mean = mean),\n      na.rm  = TRUE,\n      .names = \"{col}_{fn}\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 4\n  row_mean x_mean y_mean z_mean\n     <dbl>  <dbl>  <dbl>  <dbl>\n1      5.5  0.108  0.220 -0.284\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAlthough it may not be self-evident from just looking at the code above, the first `mean` in the `list(mean = mean)` name-function pair is a name that we are choosing to be passed to the new column names. Theoretically, we could have picked any name. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  summarise(\n    across(\n      .cols  = everything(),\n      .fns   = list(r4epi = mean),\n      na.rm  = TRUE,\n      .names = \"{col}_{fn}\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 4\n  row_r4epi x_r4epi y_r4epi z_r4epi\n      <dbl>   <dbl>   <dbl>   <dbl>\n1       5.5   0.108   0.220  -0.284\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe second `mean` in the `list(mean = mean)` name-function pair is the name of the actual function we want to apply to the columns in `.cols`. This part of the name-function pair must be the name of the function that we actually want to apply to the columns in `.cols`. Otherwise, we will get an error:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  summarise(\n    across(\n      .cols  = everything(),\n      .fns   = list(mean = r4epi),\n      na.rm  = TRUE,\n      .names = \"{col}_{fn}\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `summarise()`:\ni In argument: `across(...)`.\nCaused by error:\n! object 'r4epi' not found\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAn additional advantage of passing a list of name-function pairs to the `.fns` argument is that we can pass *multiple* functions at once. For example, let's say that we want the minimum and maximum value of each column in our data frame. Without `across()` we might do that analysis like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  summarise(\n    x_min = min(x, na.rm = TRUE),\n    x_max = max(x, na.rm = TRUE),\n    y_min = min(y, na.rm = TRUE),\n    y_max = max(y, na.rm = TRUE),\n    z_min = min(z, na.rm = TRUE),\n    z_max = max(z, na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 6\n  x_min x_max y_min y_max z_min z_max\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 -1.27  1.72 -1.97  1.79 -1.14  1.25\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut, we can simply pass `min` and `max` as a list of name-function pairs if we use `across()`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  summarise(\n    across(\n      .cols  = everything(),\n      .fns   = list(min = min, max = max),\n      na.rm  = TRUE,\n      .names = \"{col}_{fn}\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 8\n  row_min row_max x_min x_max y_min y_max z_min z_max\n    <int>   <int> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1       1      10 -1.27  1.72 -1.97  1.79 -1.14  1.25\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHow great is that?!?\n\nSo, we've seen how to pass an individual function to the `.fns` argument and we've seen how to pass a list containing multiple functions to the `.fns` argument. There is actually a third syntax for passing functions to the `.fns` argument. The `across()` documentation calls it \"a purrr-style lambda\". This can be a little bit confusing, so I'm going to show you an example, and then walk through it step by step.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  summarise(\n    across(\n      .cols  = everything(),\n      .fns   = ~ mean(.x, na.rm = TRUE),\n      .names = \"{col}_mean\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 4\n  row_mean x_mean y_mean z_mean\n     <dbl>  <dbl>  <dbl>  <dbl>\n1      5.5  0.108  0.220 -0.284\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe purrr-style lambda always begins with the tilde symbol (\\~). Then we type out a function call behind the tilde symbol. We place the special `.x` symbol inside the function call where we would normally want to type the name of the column we want the function to operate on. The `across()` function will then substitute each column name we passed to the `.cols` argument for `.x` sequentially. In the example above, there isn't really any good reason to use this syntax. However, this syntax can be useful at times. We will see some examples below.\n\n## Across with mutate\n\nWe've already seen a number of examples of manipulating columns of our data frames using the `mutate()` function. In this section, we are going to take a look at two examples where using the `across()` function inside `mutate()` will allow us to apply the same manipulation to multiple columns in our data frame at once.\n\nLet's go ahead and simulate the same `demographics` data frame we simulated for the [recoding missing](../conditional_operations/conditional_operations.qmd) section of the conditional operations chapter. Let's also add two new columns: a four-category education column and a six-category income column. For all columns except `id` and `age`, a value of `7` represents \"Don't know\" and a value of `9` represents \"refused.\"\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\ndemographics <- tibble(\n  id       = 1:10,\n  age      = c(sample(1:30, 9, TRUE), NA),\n  race     = c(1, 2, 1, 4, 7, 1, 2, 9, 1, 3),\n  hispanic = c(7, 0, 1, 0, 1, 0, 1, 9, 0, 1),\n  edu_4cat = c(4, 2, 9, 1, 2, 3, 4, 9, 3, 3),\n  inc_6cat = c(1, 4, 1, 1, 5, 3, 2, 2, 7, 9)\n) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 6\n      id   age  race hispanic edu_4cat inc_6cat\n   <int> <int> <dbl>    <dbl>    <dbl>    <dbl>\n 1     1    15     1        7        4        1\n 2     2    19     2        0        2        4\n 3     3    14     1        1        9        1\n 4     4     3     4        0        1        1\n 5     5    10     7        1        2        5\n 6     6    18     1        0        3        3\n 7     7    22     2        1        4        2\n 8     8    11     9        9        9        2\n 9     9     5     1        0        3        7\n10    10    NA     3        1        3        9\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhen working with data like this, it's common to want to recode all the `7`'s and `9`'s to `NA`'s. We saw how to do that one column at a time already:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics %>% \n  mutate(\n    race     = if_else(race == 7 | race == 9, NA_real_, race),\n    hispanic = if_else(race == 7 | hispanic == 9, NA_real_, hispanic),\n    edu_4cat = if_else(edu_4cat == 7 | edu_4cat == 9, NA_real_, edu_4cat)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 6\n      id   age  race hispanic edu_4cat inc_6cat\n   <int> <int> <dbl>    <dbl>    <dbl>    <dbl>\n 1     1    15     1        7        4        1\n 2     2    19     2        0        2        4\n 3     3    14     1        1       NA        1\n 4     4     3     4        0        1        1\n 5     5    10    NA       NA        2        5\n 6     6    18     1        0        3        3\n 7     7    22     2        1        4        2\n 8     8    11    NA       NA       NA        2\n 9     9     5     1        0        3        7\n10    10    NA     3        1        3        9\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüö©In the code chunk above, we have essentially the same code copied more than twice. That's a red flag that we should be thinking about removing unnecessary repetition from our code.\n\nAlso, did you notice that we forgot to replace `race` with `hispanic` in `hispanic = if_else(race == 7 | hispanic == 9, NA_real_, hispanic)`? This time, we didn't write \"forgot\" in quotes because we *really did forget* and only noticed it later. In this case, the error caused a value of `1` to be recoded to `NA` in the `hispanic` column. These typos we've been talking about really do happen -- even to me!\n\nHere's how we can use `across()` in this situation:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndemographics %>% \n  mutate(\n    across(\n      .cols = c(-id, -age),\n      .fns  = ~ if_else(.x == 7 | .x == 9, NA_real_, .x)\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 6\n      id   age  race hispanic edu_4cat inc_6cat\n   <int> <int> <dbl>    <dbl>    <dbl>    <dbl>\n 1     1    15     1       NA        4        1\n 2     2    19     2        0        2        4\n 3     3    14     1        1       NA        1\n 4     4     3     4        0        1        1\n 5     5    10    NA        1        2        5\n 6     6    18     1        0        3        3\n 7     7    22     2        1        4        2\n 8     8    11    NA       NA       NA        2\n 9     9     5     1        0        3       NA\n10    10    NA     3        1        3       NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n-   We used a purrr-style lambda to replace `7`'s and `9`'s in all columns in our data frame, except `id` and `age`, with `NA`.\n\n-   Remember, the special `.x` symbol is just shorthand for each column passed to the `.cols` argument.\n\nAs another example, let's say that we are once again working with data from a drug trial that includes a list of side effects for each person:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\ndrug_trial <- tibble(\n  id           = 1:10,\n  se_headache  = sample(0:1, 10, TRUE),\n  se_diarrhea  = sample(0:1, 10, TRUE),\n  se_dry_mouth = sample(0:1, 10, TRUE),\n  se_nausea    = sample(0:1, 10, TRUE)\n) %>% \n print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 5\n      id se_headache se_diarrhea se_dry_mouth se_nausea\n   <int>       <int>       <int>        <int>     <int>\n 1     1           0           1            0         0\n 2     2           0           1            1         1\n 3     3           0           1            0         0\n 4     4           1           0            0         1\n 5     5           0           1            0         1\n 6     6           1           0            0         0\n 7     7           1           1            1         0\n 8     8           1           0            1         0\n 9     9           0           0            0         0\n10    10           0           0            1         1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow, we want to create a factor version of each of the side effect columns. We've already learned how to do so one column at a time:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  mutate(\n    se_headache_f  = factor(se_headache, 0:1, c(\"No\", \"Yes\")),\n    se_diarrhea_f  = factor(se_diarrhea, 0:1, c(\"No\", \"Yes\")),\n    se_dry_mouth_f = factor(se_dry_mouth, 0:1, c(\"No\", \"Yes\"))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 8\n      id se_headache se_diarrhea se_dry_mouth se_nausea se_headache_f\n   <int>       <int>       <int>        <int>     <int> <fct>        \n 1     1           0           1            0         0 No           \n 2     2           0           1            1         1 No           \n 3     3           0           1            0         0 No           \n 4     4           1           0            0         1 Yes          \n 5     5           0           1            0         1 No           \n 6     6           1           0            0         0 Yes          \n 7     7           1           1            1         0 Yes          \n 8     8           1           0            1         0 Yes          \n 9     9           0           0            0         0 No           \n10    10           0           0            1         1 No           \n# i 2 more variables: se_diarrhea_f <fct>, se_dry_mouth_f <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüö©Once again, we have essentially the same code copied more than twice. That's a red flag that we should be thinking about removing unnecessary repetition from our code. Here's how we can use `across()` to do so:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  mutate(\n    across(\n      .cols  = starts_with(\"se\"),\n      .fns   = ~ factor(.x, 0:1, c(\"No\", \"Yes\")),\n      .names = \"{col}_f\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 9\n      id se_headache se_diarrhea se_dry_mouth se_nausea se_headache_f\n   <int>       <int>       <int>        <int>     <int> <fct>        \n 1     1           0           1            0         0 No           \n 2     2           0           1            1         1 No           \n 3     3           0           1            0         0 No           \n 4     4           1           0            0         1 Yes          \n 5     5           0           1            0         1 No           \n 6     6           1           0            0         0 Yes          \n 7     7           1           1            1         0 Yes          \n 8     8           1           0            1         0 Yes          \n 9     9           0           0            0         0 No           \n10    10           0           0            1         1 No           \n# i 3 more variables: se_diarrhea_f <fct>, se_dry_mouth_f <fct>,\n#   se_nausea_f <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n-   We used a purrr-style lambda to create a factor version of all the side effect columns in our data frame.\n\n-   We used the `.names` argument to add an \"\\_f\" to the end of the new column names.\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n## Across with summarise\n\nLet's return to the `ehr` data frame we used in the chapter on working with character strings for our first example of using `across()` inside of `summarise`.\n\n[You may click here to download this file to your computer](https://github.com/brad-cannell/r4epi/blob/master/data/ehr.Rds).\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We will need here, readr and stringr in the examples below\nlibrary(readr)\nlibrary(stringr)\nlibrary(here)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read in the data\nehr <- read_rds(\"ehr.Rds\")\n```\n:::\n\n\n\n\n\n\nFor this example, the only column we will concern ourselves with is the `symptoms` column:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymptoms <- ehr %>% \n  select(symptoms) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 x 1\n   symptoms                            \n   <chr>                               \n 1 \"\\\"Pain\\\", \\\"Headache\\\", \\\"Nausea\\\"\"\n 2 \"Pain\"                              \n 3 \"Pain\"                              \n 4 \"\\\"Nausea\\\", \\\"Headache\\\"\"          \n 5 \"\\\"Pain\\\", \\\"Headache\\\"\"            \n 6 \"\\\"Nausea\\\", \\\"Headache\\\"\"          \n 7 \"Pain\"                              \n 8  <NA>                               \n 9 \"Pain\"                              \n10  <NA>                               \n11 \"\\\"Nausea\\\", \\\"Headache\\\"\"          \n12 \"\\\"Headache\\\", \\\"Pain\\\", \\\"Nausea\\\"\"\n13 \"Headache\"                          \n14 \"\\\"Headache\\\", \\\"Pain\\\", \\\"Nausea\\\"\"\n15  <NA>                               \n```\n\n\n:::\n:::\n\n\n\n\n\n\nYou may recall that we created dummy variables for each symptom like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymptoms <- symptoms %>% \n  mutate(\n    pain     = str_detect(symptoms, \"Pain\"),\n    headache = str_detect(symptoms, \"Headache\"),\n    nausea   = str_detect(symptoms, \"Nausea\")\n  ) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 x 4\n   symptoms                             pain  headache nausea\n   <chr>                                <lgl> <lgl>    <lgl> \n 1 \"\\\"Pain\\\", \\\"Headache\\\", \\\"Nausea\\\"\" TRUE  TRUE     TRUE  \n 2 \"Pain\"                               TRUE  FALSE    FALSE \n 3 \"Pain\"                               TRUE  FALSE    FALSE \n 4 \"\\\"Nausea\\\", \\\"Headache\\\"\"           FALSE TRUE     TRUE  \n 5 \"\\\"Pain\\\", \\\"Headache\\\"\"             TRUE  TRUE     FALSE \n 6 \"\\\"Nausea\\\", \\\"Headache\\\"\"           FALSE TRUE     TRUE  \n 7 \"Pain\"                               TRUE  FALSE    FALSE \n 8  <NA>                                NA    NA       NA    \n 9 \"Pain\"                               TRUE  FALSE    FALSE \n10  <NA>                                NA    NA       NA    \n11 \"\\\"Nausea\\\", \\\"Headache\\\"\"           FALSE TRUE     TRUE  \n12 \"\\\"Headache\\\", \\\"Pain\\\", \\\"Nausea\\\"\" TRUE  TRUE     TRUE  \n13 \"Headache\"                           FALSE TRUE     FALSE \n14 \"\\\"Headache\\\", \\\"Pain\\\", \\\"Nausea\\\"\" TRUE  TRUE     TRUE  \n15  <NA>                                NA    NA       NA    \n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\nSome of you may have noticed that we repeated ourselves more than twice in the code chunk above and thought about using `across()` to remove it. Unfortunately, `across()` won't solve our problem in this situation. We will need some of the tools that we learn about in later chapters if we want to remove this repetition.\n:::\n\nAnd finally, we used the `table()` function to get a count of how many people reported having a headache:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(symptoms$headache)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n    4     8 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis is where the example stopped in the chapter on working with character strings. However, what if we wanted to know how many people reported the other symptoms as well? Well, we could repeatedly call the `table()` function:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(symptoms$pain)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n    4     8 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(symptoms$nausea)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFALSE  TRUE \n    6     6 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut, that would cause us to copy and paste repeatedly. Additionally, wouldn't it be nice to view these counts in a way that makes them easier to compare? One solution would be to use `summarise()` like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymptoms %>% \n  summarise(\n    had_headache = sum(headache, na.rm = TRUE),\n    had_pain     = sum(pain, na.rm = TRUE),\n    had_nausea   = sum(nausea, na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n  had_headache had_pain had_nausea\n         <int>    <int>      <int>\n1            8        8          6\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis works, but we can do better with `across()`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymptoms %>% \n  summarise(\n    across(\n      .cols  = c(headache, pain, nausea),\n      .fns   = ~ sum(.x, na.rm = TRUE)\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n  headache  pain nausea\n     <int> <int>  <int>\n1        8     8      6\n```\n\n\n:::\n:::\n\n\n\n\n\n\nGreat! But, wouldn't it be nice to know the proportion of people with each symptom as well? You may recall that R treats `TRUE` and `FALSE` as `1` and `0` when used in a mathematical operation. Additionally, you may already be aware that the mean of a set of `1`'s and `0`'s is equal to the proportion of `1`'s in the set. For example, there are three ones and three zeros in the set `(1, 1, 1, 0, 0, 0)`. The proportion of `1`'s in the set is 3 out of 6, which is 0.5. Equivalently, the mean value of the set is (1 + 1 + 1 + 0 + 0 + 0) / 6, which equals 3 / 6, which is 0.5. So, when we have dummy variables like `headache`, `pain`, and `nausea` above, passing them to the `mean()` function returns the proportion of `TRUE` values. In this case, the proportion of people who had each symptom. We know we can do that calculation like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymptoms %>% \n  summarise(\n    had_headache = mean(headache, na.rm = TRUE),\n    had_pain     = mean(pain, na.rm = TRUE),\n    had_nausea   = mean(nausea, na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n  had_headache had_pain had_nausea\n         <dbl>    <dbl>      <dbl>\n1        0.667    0.667        0.5\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAs before, we can do better with the `across()` function like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymptoms %>% \n  summarise(\n    across(\n      .cols = c(pain, headache, nausea),\n      .fns  = ~ mean(.x, na.rm = TRUE)\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n   pain headache nausea\n  <dbl>    <dbl>  <dbl>\n1 0.667    0.667    0.5\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow, at this point, we might think, \"wouldn't it be nice to see the count *and* the proportion in the same result?\" Well, we can do that by supplying our purrr-style lambdas as functions in a list of name-function pairs like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymptom_summary <- symptoms %>% \n  summarise(\n    across(\n      .cols = c(pain, headache, nausea),\n      .fns  = list(\n        count = ~ sum(.x, na.rm = TRUE),\n        prop  = ~ mean(.x, na.rm = TRUE)\n      )\n    )\n  ) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 6\n  pain_count pain_prop headache_count headache_prop nausea_count nausea_prop\n       <int>     <dbl>          <int>         <dbl>        <int>       <dbl>\n1          8     0.667              8         0.667            6         0.5\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIn this case, it's probably fine to stop here. But, what if we had 20 or 30 symptoms that we were analyzing? It would be really difficult to read and compare them arranged horizontally like this, wouldn't it?\n\nDo you recall us discussing restructuring our results in the [chapter on restructuring data frames](../restructuring_data_frames/restructuring_data_frames.qmd)? This is a circumstance where we might want to use `pivot_longer()` to make our results easier to read and interpret:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymptom_summary %>% \n  tidyr::pivot_longer(\n    cols      = everything(),\n    names_to  = c(\"symptom\", \".value\"),\n    names_sep = \"_\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  symptom  count  prop\n  <chr>    <int> <dbl>\n1 pain         8 0.667\n2 headache     8 0.667\n3 nausea       6 0.5  \n```\n\n\n:::\n:::\n\n\n\n\n\n\nThere! Isn't that result much easier to read?\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nFor our final example of this section, let's return the first example from the [writing functions chapter](../writing_functions/writing_functions.qmd). We started with some simulated study data:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudy <- tibble(\n  age       = c(32, 30, 32, 29, 24, 38, 25, 24, 48, 29, 22, 29, 24, 28, 24, 25, \n                25, 22, 25, 24, 25, 24, 23, 24, 31, 24, 29, 24, 22, 23, 26, 23, \n                24, 25, 24, 33, 27, 25, 26, 26, 26, 26, 26, 27, 24, 43, 25, 24, \n                27, 28, 29, 24, 26, 28, 25, 24, 26, 24, 26, 31, 24, 26, 31, 34, \n                26, 25, 27, NA),\n  age_group = c(2, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n                1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, \n                1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, \n                2, 1, 1, 1, NA),\n  gender    = c(2, 1, 1, 2, 1, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, \n                1, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, \n                1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 2, 1, \n                1, 1, 2, 1, NA),\n  ht_in     = c(70, 63, 62, 67, 67, 58, 64, 69, 65, 68, 63, 68, 69, 66, 67, 65, \n                64, 75, 67, 63, 60, 67, 64, 73, 62, 69, 67, 62, 68, 66, 66, 62, \n                64, 68, NA, 68, 70, 68, 68, 66, 71, 61, 62, 64, 64, 63, 67, 66, \n                69, 76, NA, 63, 64, 65, 65, 71, 66, 65, 65, 71, 64, 71, 60, 62, \n                61, 69, 66, NA),\n  wt_lbs    = c(216, 106, 145, 195, 143, 125, 138, 140, 158, 167, 145, 297, 146, \n                125, 111, 125, 130, 182, 170, 121, 98, 150, 132, 250, 137, 124, \n                186, 148, 134, 155, 122, 142, 110, 132, 188, 176, 188, 166, 136, \n                147, 178, 125, 102, 140, 139, 60, 147, 147, 141, 232, 186, 212, \n                110, 110, 115, 154, 140, 150, 130, NA, 171, 156, 92, 122, 102, \n                163, 141, NA),\n  bmi       = c(30.99, 18.78, 26.52, 30.54, 22.39, 26.12, 23.69, 20.67, 26.29, \n                25.39, 25.68, 45.15, 21.56, 20.17, 17.38, 20.8, 22.31, 22.75, \n                26.62, 21.43, 19.14, 23.49, 22.66, 32.98, 25.05, 18.31, 29.13, \n                27.07, 20.37, 25.01, 19.69, 25.97, 18.88, 20.07, NA, 26.76, \n                26.97, 25.24, 20.68, 23.72, 24.82, 23.62, 18.65, 24.03, 23.86, \n                10.63, 23.02, 23.72, 20.82, 28.24, NA, 37.55, 18.88, 18.3, \n                19.13, 21.48, 22.59, 24.96, 21.63, NA, 29.35, 21.76, 17.97, \n                22.31, 19.27, 24.07, 22.76, NA),\n  bmi_3cat  = c(3, 1, 2, 3, 1, 2, 1, 1, 2, 2, 2, 3, 1, 1, 1, 1, 1, 1, 2, 1, 1, \n                1, 1, 3, 2, 1, 2, 2, 1, 2, 1, 2, 1, 1, NA, 2, 2, 2, 1, 1, 1, 1, \n                1, 1, 1, 1, 1, 1, 1, 2, NA, 3, 1, 1, 1, 1, 1, 1, 1, NA, 2, 1, \n                1, 1, 1, 1, 1, NA)\n) %>% \n  mutate(\n    age_group = factor(age_group, labels = c(\"Younger than 30\", \"30 and Older\")),\n    gender    = factor(gender, labels = c(\"Female\", \"Male\")),\n    bmi_3cat  = factor(bmi_3cat, labels = c(\"Normal\", \"Overweight\", \"Obese\"))\n  ) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 68 x 7\n     age age_group       gender ht_in wt_lbs   bmi bmi_3cat  \n   <dbl> <fct>           <fct>  <dbl>  <dbl> <dbl> <fct>     \n 1    32 30 and Older    Male      70    216  31.0 Obese     \n 2    30 30 and Older    Female    63    106  18.8 Normal    \n 3    32 30 and Older    Female    62    145  26.5 Overweight\n 4    29 Younger than 30 Male      67    195  30.5 Obese     \n 5    24 Younger than 30 Female    67    143  22.4 Normal    \n 6    38 30 and Older    Female    58    125  26.1 Overweight\n 7    25 Younger than 30 Female    64    138  23.7 Normal    \n 8    24 Younger than 30 Male      69    140  20.7 Normal    \n 9    48 30 and Older    Male      65    158  26.3 Overweight\n10    29 Younger than 30 Male      68    167  25.4 Overweight\n# i 58 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd wrote our own function to calculate the number of missing values, mean, median, min, and max for all of the continuous variables:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_stats <- function(var) {\n  study %>% \n    summarise(\n      n_miss = sum(is.na({{ var }})),\n      mean   = mean({{ var }}, na.rm = TRUE),\n      median = median({{ var }}, na.rm = TRUE),\n      min    = min({{ var }}, na.rm = TRUE),\n      max    = max({{ var }}, na.rm = TRUE)\n    )\n}\n```\n:::\n\n\n\n\n\n\nWe then used that function to calculate our statistics of interest for each continuous variable:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_stats(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 5\n  n_miss  mean median   min   max\n   <int> <dbl>  <dbl> <dbl> <dbl>\n1      1  26.9     26    22    48\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_stats(ht_in)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 5\n  n_miss  mean median   min   max\n   <int> <dbl>  <dbl> <dbl> <dbl>\n1      3  66.0     66    58    76\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_stats(wt_lbs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 5\n  n_miss  mean median   min   max\n   <int> <dbl>  <dbl> <dbl> <dbl>\n1      2  148.   142.    60   297\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinuous_stats(bmi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 5\n  n_miss  mean median   min   max\n   <int> <dbl>  <dbl> <dbl> <dbl>\n1      4  23.6   22.9  10.6  45.2\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis is definitely an improvement over all the copying and pasting we were doing before we wrote our own function. However, there is still some unnecessary repetition above. One way we can remove this repetition is to use `across()` like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary_stats <- study %>% \n  summarise(\n    across(\n      .cols = c(age, ht_in, wt_lbs, bmi),\n      .fns  = list(\n        n_miss = ~ sum(is.na(.x)),\n        mean   = ~ mean(.x, na.rm = TRUE),\n        median = ~ median(.x, na.rm = TRUE),\n        min    = ~ min(.x, na.rm = TRUE),\n        max    = ~ max(.x, na.rm = TRUE)\n      )\n    ) \n  ) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 20\n  age_n_miss age_mean age_median age_min age_max ht_in_n_miss ht_in_mean\n       <int>    <dbl>      <dbl>   <dbl>   <dbl>        <int>      <dbl>\n1          1     26.9         26      22      48            3       66.0\n# i 13 more variables: ht_in_median <dbl>, ht_in_min <dbl>, ht_in_max <dbl>,\n#   wt_lbs_n_miss <int>, wt_lbs_mean <dbl>, wt_lbs_median <dbl>,\n#   wt_lbs_min <dbl>, wt_lbs_max <dbl>, bmi_n_miss <int>, bmi_mean <dbl>,\n#   bmi_median <dbl>, bmi_min <dbl>, bmi_max <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis method works, but it has the same problem that our symptom summaries had above. Our results are hard to read and interpret because they are arranged horizontally. We can once again pivot this data longer, but it won't be *quite* as easy as it was before. Our first attempt might look like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary_stats %>% \n  tidyr::pivot_longer(\n    cols      = everything(),\n    names_to  = c(\"characteristic\", \".value\"),\n    names_sep = \"_\"\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expected 2 pieces. Additional pieces discarded in 12 rows [1, 6, 7, 8, 9, 10,\n11, 12, 13, 14, 15, 16].\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 8\n   characteristic     n  mean median   min   max  `in`   lbs\n   <chr>          <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 age                1  26.9   26    22    48    NA     NA \n 2 ht                NA  NA     NA    NA    NA     3     NA \n 3 ht                NA  NA     NA    NA    NA    66.0   NA \n 4 ht                NA  NA     NA    NA    NA    66     NA \n 5 ht                NA  NA     NA    NA    NA    58     NA \n 6 ht                NA  NA     NA    NA    NA    76     NA \n 7 wt                NA  NA     NA    NA    NA    NA      2 \n 8 wt                NA  NA     NA    NA    NA    NA    148.\n 9 wt                NA  NA     NA    NA    NA    NA    142.\n10 wt                NA  NA     NA    NA    NA    NA     60 \n11 wt                NA  NA     NA    NA    NA    NA    297 \n12 bmi                4  23.6   22.9  10.6  45.2  NA     NA \n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhat do you think the problem is here?\n\nWell, we passed an underscore to the `names_sep` argument. This tells `pivot_longer()` that that character string on the left side of the underscore should make up the values of the new `characteristic` column and each unique character string on the right side of the underscore should be used to create a new column name. In the symptoms data, this worked fine because all of the column names followed this pattern (e.g., `pain_count` and `pain_prop`). But, do the column names in `summary_stats` always follow this pattern? What about `age_n_miss` and `ht_in_n_miss`? All the extra underscores in the column names makes this pattern ineffective.\n\nThere are probably many ways we could address this problem. We think the most straightforward way is probably to go back to the code we used to create `summary_stats` and use the `.names` argument to separate the column name and statistic name with a character other than an underscore. Maybe a hyphen instead:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary_stats <- study %>% \n  summarise(\n    across(\n      .cols  = c(age, ht_in, wt_lbs, bmi),\n      .fns   = list(\n        n_miss = ~ sum(is.na(.x)),\n        mean   = ~ mean(.x, na.rm = TRUE),\n        median = ~ median(.x, na.rm = TRUE),\n        min    = ~ min(.x, na.rm = TRUE),\n        max    = ~ max(.x, na.rm = TRUE)\n      ),\n      .names = \"{col}-{fn}\" # This is the new part of the code\n    ) \n  ) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 20\n  `age-n_miss` `age-mean` `age-median` `age-min` `age-max` `ht_in-n_miss`\n         <int>      <dbl>        <dbl>     <dbl>     <dbl>          <int>\n1            1       26.9           26        22        48              3\n# i 14 more variables: `ht_in-mean` <dbl>, `ht_in-median` <dbl>,\n#   `ht_in-min` <dbl>, `ht_in-max` <dbl>, `wt_lbs-n_miss` <int>,\n#   `wt_lbs-mean` <dbl>, `wt_lbs-median` <dbl>, `wt_lbs-min` <dbl>,\n#   `wt_lbs-max` <dbl>, `bmi-n_miss` <int>, `bmi-mean` <dbl>,\n#   `bmi-median` <dbl>, `bmi-min` <dbl>, `bmi-max` <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow, we can simply pass a hyphen to the `names_sep` argument to `pivot_longer()`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary_stats %>% \n  tidyr::pivot_longer(\n    cols      = everything(),\n    names_to  = c(\"characteristic\", \".value\"),\n    names_sep = \"-\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 6\n  characteristic n_miss  mean median   min   max\n  <chr>           <int> <dbl>  <dbl> <dbl> <dbl>\n1 age                 1  26.9   26    22    48  \n2 ht_in               3  66.0   66    58    76  \n3 wt_lbs              2 148.   142.   60   297  \n4 bmi                 4  23.6   22.9  10.6  45.2\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLook at how much easier those results are to read!\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(study, summary_stats, continuous_stats)\n```\n:::\n\n\n\n\n\n\n## Across with filter\n\nWe've already discussed [complete case analysis](../appendices/glossary.qmd#glossary-complete-case-analysis) multiple times in this book. That is, including only the rows from our data frame that don't have any missing values in our analysis. Additionally, we've already seen how we can use the `filter()` function to remove the rows of a *single* column where the data are missing. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  filter(!is.na(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 x 4\n    row       x      y      z\n  <int>   <dbl>  <dbl>  <dbl>\n1     1 -0.560   1.22  -1.07 \n2     3  1.56    0.401 -1.03 \n3     4  0.0705 NA     -0.729\n4     5  0.129  -0.556 -0.625\n5     6  1.72    1.79  NA    \n6     7  0.461   0.498  0.838\n7     8 -1.27   -1.97   0.153\n8     9 -0.687   0.701 -1.14 \n9    10 -0.446  -0.473  1.25 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice that row 2 -- the row that had a missing value for `x` -- is no longer in the data frame, and we can now easily calculate the mean value of `x`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  filter(!is.na(x)) %>% \n  summarise(mean = mean(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n   mean\n  <dbl>\n1 0.108\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHowever, we want to remove the rows that have a missing value in *any* column -- not just `x`. We could get this result using multiple sequential `filter()` functions like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  filter(!is.na(x)) %>% \n  filter(!is.na(y)) %>% \n  filter(!is.na(z))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 x 4\n    row      x      y      z\n  <int>  <dbl>  <dbl>  <dbl>\n1     1 -0.560  1.22  -1.07 \n2     3  1.56   0.401 -1.03 \n3     5  0.129 -0.556 -0.625\n4     7  0.461  0.498  0.838\n5     8 -1.27  -1.97   0.153\n6     9 -0.687  0.701 -1.14 \n7    10 -0.446 -0.473  1.25 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nAs you can see, rows 2, 4, and 6 -- the rows with a missing value for `x`, `y`, and `z` -- were dropped.\n\nüö©Of course, in the code chunk above, we have essentially the same code copied more than twice. That's a red flag that we should be thinking about removing unnecessary repetition from our code.\n\nAt this point in the book, our first thought might be to use the `across()` function, inside the `filter()` function, to remove *all* of the rows rows with missing values from our data frame. However, as of `dplyr version 1.0.4`, using the `across()` function inside of `filter()` is deprecated. That means we shouldn't use it anymore. Instead, we should use the `if_any()` or `if_all()` functions, which take the exact same arguments as `across()`. In the code chunk below, we will show you how to solve this problem, then we will dissect the solution below.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  filter(\n    if_all(\n      .cols = c(x:z),\n      .fns  = ~ !is.na(.x)\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 x 4\n    row      x      y      z\n  <int>  <dbl>  <dbl>  <dbl>\n1     1 -0.560  1.22  -1.07 \n2     3  1.56   0.401 -1.03 \n3     5  0.129 -0.556 -0.625\n4     7  0.461  0.498  0.838\n5     8 -1.27  -1.97   0.153\n6     9 -0.687  0.701 -1.14 \n7    10 -0.446 -0.473  1.25 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n-   You can type `?dplyr::if_any` or `?dplyr::if_all` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n-   We used the `if_all()` function inside of the `filter()` function to keep only the rows in our data frame that had nonmissing values for *all* of the columns `x`, `y`, and `z`.\n\n-   We passed the value `c(x:z)` to the `.cols` argument. This told R to apply the function passed to the `.fns` argument to the columns `x` through `z` inclusive.\n\n-   We used a purrr-style lambda to test whether or not each value of each of the columns passed to `.cols` is NOT missing.\n\n-   Remember, the special `.x` symbol is just shorthand for each column passed to the `.cols` argument.\n\nSo, how does this work? Well, first let's remember that the `is.na()` function returns `TRUE` when the value of the vector passed to it is missing and `FALSE` when it is not missing. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(df_xyz$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWe can then use the `!` operator to \"flip\" those results. In other words, to return `TRUE` when the value of the vector passed to it is *not* missing and `FALSE` when it is missing. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!is.na(df_xyz$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe filter() function] then returns the rows from the data frame where the values returned by `!is.na()` are `TRUE` and drops the rows where they are `FALSE`. For example, we can copy and paste the TRUE/FALSE values above to keep only the rows with nonmissing values for `x`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  filter(c(TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 x 4\n    row       x      y      z\n  <int>   <dbl>  <dbl>  <dbl>\n1     1 -0.560   1.22  -1.07 \n2     3  1.56    0.401 -1.03 \n3     4  0.0705 NA     -0.729\n4     5  0.129  -0.556 -0.625\n5     6  1.72    1.79  NA    \n6     7  0.461   0.498  0.838\n7     8 -1.27   -1.97   0.153\n8     9 -0.687   0.701 -1.14 \n9    10 -0.446  -0.473  1.25 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow, let's repeat this process for the columns `y` and `z` as well.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n!is.na(df_xyz$y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n!is.na(df_xyz$z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNext, let's stack these results next to each other to make them even easier to view.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnot_missing <- tibble(\n  row = 1:10,\n  x   = !is.na(df_xyz$x),\n  y   = !is.na(df_xyz$y),\n  z   = !is.na(df_xyz$z)\n) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 4\n     row x     y     z    \n   <int> <lgl> <lgl> <lgl>\n 1     1 TRUE  TRUE  TRUE \n 2     2 FALSE TRUE  TRUE \n 3     3 TRUE  TRUE  TRUE \n 4     4 TRUE  FALSE TRUE \n 5     5 TRUE  TRUE  TRUE \n 6     6 TRUE  TRUE  FALSE\n 7     7 TRUE  TRUE  TRUE \n 8     8 TRUE  TRUE  TRUE \n 9     9 TRUE  TRUE  TRUE \n10    10 TRUE  TRUE  TRUE \n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n-   We created a data frame that contains the value `TRUE` in each position where `df_xyz` has a nonmissing value and `FALSE` in each position where `df_xyz` has a missing value. We wouldn't typically create this for our data analysis. We just created it here for teaching purposes.\n\nYou can think of the data frame of `TRUE` and `FALSE` values above as an intermediate product that `if_any()` and `if_all()` uses \"under the hood\" to decide which rows to keep. We think using this data frame as a conceptual model makes it a little easier to understand how `if_any()` and `if_all()` differ.\n\n`if_any()` will keep the rows where *any* value of `x`, `y`, *or* `z` are `TRUE`. In this case, there is at least one `TRUE` value in every row. Therefore, we would expect `if_any()` to return all rows in our data frame. And, that's exactly what happens.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  filter(\n    if_any(\n      .cols = c(x:z),\n      .fns  = ~ !is.na(.x)\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 4\n     row       x      y      z\n   <int>   <dbl>  <dbl>  <dbl>\n 1     1 -0.560   1.22  -1.07 \n 2     2 NA       0.360 -0.218\n 3     3  1.56    0.401 -1.03 \n 4     4  0.0705 NA     -0.729\n 5     5  0.129  -0.556 -0.625\n 6     6  1.72    1.79  NA    \n 7     7  0.461   0.498  0.838\n 8     8 -1.27   -1.97   0.153\n 9     9 -0.687   0.701 -1.14 \n10    10 -0.446  -0.473  1.25 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nOn the other hand, `if_all()` will the keep the rows where *all* value of `x`, `y`, *and* `z` are `TRUE.` In this case, there is at least one `FALSE` value in rows 2, 4, and 6. Therefore, we would expect `if_all()` to return all rows in our data frame *except* rows 2, 4, and 6. That's exactly what happens, and it's exaclty the result we want.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_xyz %>% \n  filter(\n    if_all(\n      .cols = c(x:z),\n      .fns  = ~ !is.na(.x)\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 x 4\n    row      x      y      z\n  <int>  <dbl>  <dbl>  <dbl>\n1     1 -0.560  1.22  -1.07 \n2     3  1.56   0.401 -1.03 \n3     5  0.129 -0.556 -0.625\n4     7  0.461  0.498  0.838\n5     8 -1.27  -1.97   0.153\n6     9 -0.687  0.701 -1.14 \n7    10 -0.446 -0.473  1.25 \n```\n\n\n:::\n:::\n\n\n\n\n\n\nBecause this is a small, simple example, using `if_all()` doesn't actually reduce the number of lines of code we wrote. But again, try to imagine if we added 20 additional columns to our data frame. We would only need to update the value we pass to the `.cols` argument. This makes our code more concise, easier to maintain, and less error-prone.\n\n## Summary\n\nWe are big fans of using `across()`, `if_any()`, and `if_all()` in conjunction with the `dplyr` verbs. They allows us to remove a lot of the unnecessary repetition from our code in a way that integrates pretty seamlessly with the tools we are already using. Perhaps you will see value in using these functions as well. In the next chapter, we will learn about using [for loops](../appendices/glossary.qmd#glossary-for-loops) to remove unnecessary repetition from our code.\n\n\n\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}