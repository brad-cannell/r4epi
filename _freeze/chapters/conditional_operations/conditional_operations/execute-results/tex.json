{
  "hash": "8de7a3cd84a238643364d0bfe88f8b1c",
  "result": {
    "engine": "knitr",
    "markdown": "# Conditional Operations\n\n<!--\n- if_else()\n- case_when()\n- Different than ifelse()\n- Different than if {} else {} - not vectorized\n- Missing data - see script.\n-->\n\nThere will often be times that we want to modify the values in one column of our data based on the values in one or more other columns in our data. For example, maybe we want to create a column that contains the region of the country someone is from, based on another column that contains the state they are from. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](values.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nwe don't really have a way to do this with the tools we currently have in our toolbox. We can manually type out all the region values, but that isn't very scalable. Wouldn't it be nice if we could just give R some rules, or conditions (e.g., TX is in the South, CA is in the West), and have R fill in the region values for us? Well, that's exactly what we are going to learn how to do in this chapter.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](conditions.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nThese kinds of operations are called conditional operations because we type in a set of conditions, R evaluates those conditions, and then executes a different process or procedure based on whether or not the condition is met.\n\nAs a silly example, let‚Äôs say that we want our daughters to wear a raincoat if it‚Äôs raining outside, but we don't want them to wear a raincoat if it is not raining outside. So, we give them a conditional request: ‚ÄúIf it‚Äôs raining outside, then make sure to wear your raincoat, please. Otherwise, please don't wear your raincoat.‚Äù \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](rain.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nIn this hypothetical scenario, they say, ‚Äúyes, dad,‚Äù and then go to the window to see if it‚Äôs raining. Then, they choose their next action (i.e., raincoat wearing) depending on whether the condition (raining) is met or not. \n\nJust like we have to ask our daughters to put on a raincoat using conditional logic, we sometimes have to ask R to execute commands using conditional logic. Additionally, we have to do so in a way that R understands. For example, we can use `dplyr`'s `if_else()` function to ask R to execute commands conditionally. Let's go ahead and take a look at an example now:\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 2\n    day weather\n  <int> <chr>  \n1     1 rain   \n2     2 rain   \n3     3 no rain\n4     4 rain   \n5     5 no rain\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we simulated some data that contains information about whether or not it rained on each of 5 days. \n\nNow, let's say that we want to create a new column in our data frame called `raincoat`. We want the value of `raincoat` to be `wear` on rainy days and `no wear` on days when it isn't raining. Here's how we can do that with the if_else() function:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n    day weather raincoat\n  <int> <chr>   <chr>   \n1     1 rain    wear    \n2     2 rain    wear    \n3     3 no rain no wear \n4     4 rain    wear    \n5     5 no rain no wear \n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `if_else()` function to assign the values `wear` and `no wear` to the column `raincoat` conditional on the values in each row of the `weather` column.\n\n* You can type `?if_else` into our R console to view the help documentation for this function and follow along with the explanation below.\n\n* The first argument to the `if_else()` function is the `condition` argument. The condition should typically be composed of a series of operands and operators (we'll talk more about these soon) that tell R the condition(s) that we want it to test. For example, is the value of `weather` equal to `rain`?\n\n* The second argument to the `if_else()` function is the `true` argument. The value passed to the `true` argument tells R what value the `if_else()` function should return when the condition is `TRUE`. In this case, we told `if_else()` to return the character value `wear`.\n\n* The third argument to the `if_else()` function is the `false` argument. The value passed to the `false` argument tells R what value the `if_else()` function should return when the condition is `FALSE`. In this case, we told `if_else()` to return the character value `no wear`.\n\n* Finally, we assigned all the values returned by the `if_else()` function to a new column that we named `raincoat`.\n\n::: {.callout-note}\nüóí**Side Note:** For the rest of the book, we will pass values to the `if_else()` function by position instead of name. In other words, we won't write `condition =`, `true =`, or `false =` anymore. However, the first value passed to the `if_else()` function will always be passed to the `condition` argument, the second value will always be passed to the `true` argument, and the third value will always be passed to the `false` argument.\n:::\n\nBefore moving on, let's dive into this a little further. R must always be able to reduce whatever value we pass to the `condition` argument of `if_else()` to TRUE or FALSE. That's how R views any expression we pass to the `condition` argument. We can literally even pass the value `TRUE` or the value `FALSE` (not that doing so has much practical application):\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"wear\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBecause the value passed to the `condition` argument is `TRUE` (in this case, literally), the `if_else()` function returns the value `wear`. What happens if we use this code to assign values to the `raincoat` column?\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n    day weather raincoat\n  <int> <chr>   <chr>   \n1     1 rain    wear    \n2     2 rain    wear    \n3     3 no rain wear    \n4     4 rain    wear    \n5     5 no rain wear    \n```\n\n\n:::\n:::\n\n\n\n\n\n\nAgain, the `if_else()` function returns the value `wear` because the value passed to the `condition` argument is `TRUE`. Then, R uses its recycling rules to copy the value `wear` to every row of the `raincoat` column. What would do you think will happen if we pass the value `FALSE` to the `condition` argument instead?\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n    day weather raincoat\n  <int> <chr>   <chr>   \n1     1 rain    no wear \n2     2 rain    no wear \n3     3 no rain no wear \n4     4 rain    no wear \n5     5 no rain no wear \n```\n\n\n:::\n:::\n\n\n\n\n\n\nHopefully, that was the result you expected. The `if_else()` function returns the value `no wear` because the value passed to the `condition` argument is `FALSE`. Then, R uses its recycling rules to copy the value `no wear` to every row of the `raincoat` column.\n\nwe can take this  a step further and actually pass a vector of logical (`TRUE`/`FALSE`) values to the `condition` argument. For example:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n    day weather raincoat\n  <int> <chr>   <chr>   \n1     1 rain    wear    \n2     2 rain    wear    \n3     3 no rain no wear \n4     4 rain    wear    \n5     5 no rain no wear \n```\n\n\n:::\n:::\n\n\n\n\n\n\nIn reality, that's sort of what we did in the very first `if_else()` example above. But, instead of typing the values manually, we used an expression that returned a vector of logical values. Specifically, we used the equality operator (`==`) to check whether or not each value in the `weather` column was equal to the value \"rain\" or not. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThat pretty much covers the basics of how the `if_else()` function works. Next, let's take a look at some of the different combinations of operands and operators that we can combine and pass to the `condition` argument of the `if_else()` function.\n\n## Operands and operators\n\nLet's start by taking a look at some commonly used operands:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](operands.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nAs we can see in the table above, operands are the _values_ we want to check, or test. Operands can be variables or they can be individual values (also called constants). The example above (`weather == \"rain\"`) contained two operands; the variable `weather` and the character constant `\"rain\"`. The operator we used in this case was the equality operator (`==`). Next, let's take a look at some other commonly used operators.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](comparison-numeric.png){width=6in}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](comparison-character.png){width=6in}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](arithmetic.png){width=6in}\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](logical.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nwe think that most of the operators above will be familiar, or a least intuitive, for most of you. However, we do want to provide a little bit of commentary for a few of them.\n\n* we haven't seen the `%in%` operator before, but we will wait to discuss it below. \n\n* Some of you may have been a little surprised by the results we get from using less than (`<`) and greater than (`>`) with characters. It's basically just testing alphabetical order. A comes before B in the alphabet, so A is less than B. Additionally, when two letters are the same, the upper-case letter is considered greater than the lowercase letter. However, alphabetical order takes precedence over case. So, b is still greater than A even though b is lowercase and A is upper case.\n\n* Many of you may not have seen the modulus operator (`%%`) before. The modulus operator returns the remainder that is left after dividing two numbers. For example, 4 divided by 2 is 2 with a remainder of 0 because 2 goes into 4 _exactly_ two times. Said another way, 2 * 2 = 4 and 4 - 4 = 0. So, `4 %% 2 = 0`. However, 3 divided by 2 is 1 with a remainder of 1 because 2 goes into 3 one time with 1 left over. Said another way, 2 * 1 = 2 and 3 - 2 = 1. So, `3 %% 2 = 1`.  How is this useful? Well, the only times we can remember using the modulus operator have been when we needed to separate even and odd rows of a data frame. For example, let's say that we have a data frame where each person has two rows. The first row always corresponds to treatment A and the second row always corresponds to treatment B. However, for some reason (maybe blinding?), there was no `treatment` column in the data when we received it. We could use the modulus operator to add a `treatment` column like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 2\n     id outcome\n  <dbl>   <dbl>\n1     1       0\n2     1       1\n3     2       1\n4     2       1\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 3\n     id outcome treatment\n  <dbl>   <dbl> <chr>    \n1     1       0 A        \n2     1       1 B        \n3     2       1 A        \n4     2       1 B        \n```\n\n\n:::\n:::\n\n\n\n\n\n\n* we also want to remind you that we should always use the `is.na()` function to check for missing values. Not the equality operator (`==`). Using the equality operator when there are missing values can give results that may be unexpected. For example:\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  name1 name2 name_match\n  <chr> <chr> <lgl>     \n1 Jon   Jon   TRUE      \n2 John  Jon   FALSE     \n3 <NA>  Jon   NA        \n```\n\n\n:::\n:::\n\n\n\n\n\n\nMany of us would expect the third value of the `name_match` column to be `FALSE` instead of `NA`. There are a couple of different ways we can get `FALSE` in the third row instead of `NA`. One way, although not necessarily the best way, is to use the `if_else()` function:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  name1 name2 name_match\n  <chr> <chr> <lgl>     \n1 Jon   Jon   TRUE      \n2 John  Jon   FALSE     \n3 <NA>  Jon   FALSE     \n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `if_else()` function to assign the value `FALSE` to the column `name_match` where the original value of `name_match` was `NA`. \n\n* The value we passed to the `condition` argument was `is.na(name_match)`. In doing so, we asked R to check each value of the `name_match` column and see if it was `NA`. \n\n* If it was `NA`, then we wanted to return the value that we passed to the `true` argument. Somewhat confusingly, the value we passed to the `true` argument was `FALSE`. All that means is that we wanted `if_else()` to return the literal value `FALSE` when the value for `name_match` was `NA`.\n\n* If the value in `name_match` was NOT `NA`, then we wanted to return the value that we passed to the `false` argument. In this case, we asked R to return the value that already exists in the `name_match` column.\n\n* In more informal language, we asked R to replace missing values in the `name_match` column with `FALSE` and leave the rest of the values unchanged. \n\n## Testing multiple conditions simultaneously\n\nSo far, we have only ever passed one condition to the `condition` argument of the `if_else()` function. However, we can pass as many conditions as we want. Having said that, more than 2, or maybe 3, gets very convoluted. Let's go ahead and take a look at a couple of examples now. We'll start by simulating some blood pressure data:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 3\n      id sysbp diasbp\n   <int> <dbl>  <dbl>\n 1     1   152     78\n 2     2   120     60\n 3     3   119     88\n 4     4   123     76\n 5     5   135     85\n 6     6    83     54\n 7     7   191    116\n 8     8   147     95\n 9     9   209    100\n10    10   166    106\n```\n\n\n:::\n:::\n\n\n\n\n\n\nA person may be categorized as having normal blood pressure when their systolic blood pressure is less than 120 mmHG _AND_ their diastolic blood pressure is less than 80 mmHG. We can use this information and the `if_else()` function to create a new column in our data frame that contains information about whether each person in our simulated data frame has normal blood pressure or not:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 4\n      id sysbp diasbp bp        \n   <int> <dbl>  <dbl> <chr>     \n 1     1   152     78 Not Normal\n 2     2   120     60 Not Normal\n 3     3   119     88 Not Normal\n 4     4   123     76 Not Normal\n 5     5   135     85 Not Normal\n 6     6    83     54 Normal    \n 7     7   191    116 Not Normal\n 8     8   147     95 Not Normal\n 9     9   209    100 Not Normal\n10    10   166    106 Not Normal\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `if_else()` function to create a new column in our data frame (`bp`) that contains information about whether each person has normal blood pressure or not. \n\n* we actually passed two conditions to the `condition` argument. The first condition was that the value of `sysbp` had to be less than `120`. The second condition was that  the value of `diasbp` had to be less than `80`. \n\n* Because we separated these conditions with the AND operator (`&`), both conditions had to be true in order for the `if_else()` function to return the value we passed to the `true` argument -- `Normal`. Otherwise, the `if_else()` function returned the value we passed to the `false` argument -- `Not Normal`.\n\n* Participant 2 had a systolic blood pressure of 120 and a diastolic blood pressure of 60. Although 60 is less than 80 (condition number 2), 120 is not less than 120 (condition number 1). So, the value returned by the `if_else()` function was `Not Normal`.\n\n* Participant 3 had a systolic blood pressure of 119 and a diastolic blood pressure of 88 Although 119 is less than 120 (condition number 1), 88 is not less than 80 (condition number 2). So, the value returned by the `if_else()` function was `Not Normal`.\n\n* Participant 6 had a systolic blood pressure of 83 and a diastolic blood pressure of 54. In this case, conditions 1 _and_ 2 were met. So, the value returned by the `if_else()` function was `Normal`.\n\nThis is useful! However, in some cases, we need to be able to test conditions sequentially, rather than simultaneously, and return a different value for each condition. \n\n## Testing a sequence of conditions\n\nLet's say that we wanted to create a new column in our `blood_pressure` data frame that contains each person's blood pressure category according to the following scale:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](bp.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nThis is the perfect opportunity to use `dplyr`'s `case_when()` function. Take a look:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 4\n      id sysbp diasbp bp                  \n   <int> <dbl>  <dbl> <chr>               \n 1     1   152     78 Hypertension Stage 2\n 2     2   120     60 Elevated            \n 3     3   119     88 Hypertension Stage 1\n 4     4   123     76 Elevated            \n 5     5   135     85 Hypertension Stage 1\n 6     6    83     54 Normal              \n 7     7   191    116 Hypertension Stage 2\n 8     8   147     95 Hypertension Stage 2\n 9     9   209    100 Hypertension Stage 2\n10    10   166    106 Hypertension Stage 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `case_when()` function to create a new column in our data frame (`bp`) that contains information about each person's blood pressure category. \n\n* You can type `?case_when` into our R console to view the help documentation for this function and follow along with the explanation below.\n\n* The `case_when()` function only has a single argument -- the `...` argument. You should pass one or more two-sided formulas separated by commas to this argument. What in the heck does that mean?\n\n  - When the help documentation refers to a two-sided formula, it means this: `LHS ~ RHS`. Here, `LHS` means left-hand side and `RHS` means right-hand side. \n  \n  - The `LHS` should be the condition or conditions that we want to test. You can think of this as being equivalent to the `condition` argument of the `if_else()` function. \n  \n  - The `RHS` should be the value we want the `case_when()` function to return when the condition on the left-hand side is met. You can think of this as being equivalent to the `true` argument of the `if_else()` function. \n  \n  - The tilde symbol (`~`) is used to separate the conditions on the left-hand side and the return values on the right-hand side. \n  \n* The `case_when()` function doesn't have a direct equivalent to the `if_else()` function's `false` argument. Instead, it evaluates each two-sided formula sequentially until if finds a condition that is met. If it never finds a condition that is met, then it returns an `NA`. We will expand on this more below.\n\n* Finally, we assigned all the values returned by the `case_when()` function to a new column that we named `bp`.\n  \n::: {.callout-note}\nüóí**Side Note:** Traditionally, the tilde symbol (`~`) is used to represent relationships in a statistical model. Here, it doesn't have that meaning. We assume this symbol was picked somewhat out of necessity. Remember, any of the comparison operators, arithmetic operators, and logical operators may be used to define a condition in the left-hand side, and commas are used to separated multiple two-sided formulas. Therefore, there aren't very many symbols left to choose from. Therefore, tilde it is. That's our guess anyway. \n:::\n\nThe `case_when()` function was really useful for creating the `bp` column above, but there was also a lot going on there. Next, we'll take a look at a slightly less complex example and clarify a few things along the way. \n\n## Recoding variables\n\nIn epidemiology, recoding variables is really common. For example, we may collect information about people's ages as a continuous variable, but decide that it makes more sense to **collapse** age into age categories for our analysis. Let's say that our analysis plan calls for assigning each of our participants to one of the following age categories: \n\n1 = `child` when the participant is less than 12 years old   \n2 = `adolescent` when the participant is between the ages of 12 and less than 18   \n3 = `adult` when the participant is 18 years old or older   \n\n::: {.callout-note}\nüóí**Side Note:** You may not have ever heard of **collapsing** variables before. It simply means combing two or more values of our variable. We can collapse continuous variables into categories, as we discussed in the example above, or we can collapse categories into broader categories (as we will see with the race category example below). After we collapse a variable, it always contains fewer (and broader) possible values than it contained before we collapsed it.\n:::\n\nwe're going to show you how to do this below using the `case_when()` function. However, we're going to do it piecemeal so that we can highlight a few important concepts. First, let's simulate some data that includes 10 participant's ages.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 2\n      id   age\n   <int> <int>\n 1     1    15\n 2     2    19\n 3     3    14\n 4     4     3\n 5     5    10\n 6     6    18\n 7     7    22\n 8     8    11\n 9     9     5\n10    10    NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThen, let's start the process of collapsing the `age` column into a new column called `age_3cat` that contains the 3 age categories we discussed above:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 3\n      id   age age_3cat\n   <int> <int>    <dbl>\n 1     1    15       NA\n 2     2    19       NA\n 3     3    14       NA\n 4     4     3        1\n 5     5    10        1\n 6     6    18       NA\n 7     7    22       NA\n 8     8    11        1\n 9     9     5        1\n10    10    NA       NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `case_when()` function to create a new column in our data frame (`age_3cat`) that will eventually categorize each participant into one of 3 categories depending on their continuous age value.\n\n* Notice that we only passed one two-sided formula to the `case_when()` function -- `age < 12 ~ 1`. \n\n  - The `RHS` of the two-sided formula is `age < 12`. This tells the `case_when()` function to check whether or not every value in the `age` column is less than `12` or not. \n  \n  - The `LHS` of the two-sided formula is `1`. This tells the `case_when()` function what value to return each time it finds a value less than `12` in the `age` column.\n  \n  - The tilde symbol is used to separate the `RHS` and the `LHS` of the two-sided formula.\n  \n* Here is how the `case_when()` function basically works. It will test the condition on the left-hand side for each value of the variable, or variables, passed to the left-hand side (i.e., `age`). If the condition is met (i.e., `< 12`), then it will return the value on the right-hand side of the tilde (i.e., `1`). If the condition is not met, it will test the condition in the next two-sided formula. When there are no more two-sided formulas, then it will return an `NA`.\n  \n  - Above, the first value in `age` is `15`. `15` is _NOT_ less than `12`. So, `case_when()` tries to move on to the next two-sided formula. However, there is no next two-sided formula. So, the first value returned by the `case_when()` function is `NA`. The same is true for the next two values of age. \n\n  -  The fourth value in `age` is `3`. `3` is less than `12`. So, the fourth value returned by the `case_when()` function is `1`. And so on...\n  \n  - Finally, after the `case_when()` function has tested all conditions, the returned values are assigned to a new column that we named `age_3cat`.\n  \n* Notice that we named the new variable `age_3cat`. We're  not sure where we picked up this naming convention, but we use it a lot when we collapse variables. The basic format is the name of variable we're collapsing, an underscore, and the number of categories in the collapsed variable. We like using this convention for two reasons. First, the resulting column names are meaningful and informative. Second, we don't have to spend any time trying to think of a different meaningful or informative name for my new variable. It's totally fine if you don't adopt this naming convention, but we would recommend that you try to use names that are more informative than `age2` or something like that.\n\n* Notice that we used a number (`1`) on the right-hand side of the two-sided formula above. We could have used a character value instead (i.e., `child`); however, for reasons we discussed in the section on factor variables, we prefer to recode my variables using numeric categories and then later creating a factor version of the variable using the `_f` naming convention.\n\nNow, let's add a second two-sided formula to our `case_when()` function.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 3\n      id   age age_3cat\n   <int> <int>    <dbl>\n 1     1    15        2\n 2     2    19       NA\n 3     3    14        2\n 4     4     3        1\n 5     5    10        1\n 6     6    18       NA\n 7     7    22       NA\n 8     8    11        1\n 9     9     5        1\n10    10    NA       NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `case_when()` function to create a new column in our data frame (`age_3cat`) that will eventually categorize each participant into one of 3 categories depending on their continuous age value.\n\n* Notice that this time we passed two two-sided formulas to the `case_when()` function -- `age < 12 ~ 1` and `age >= 12 & age < 18 ~ 2`. \n\n  - Notice that we separated the two two-sided formulas with a comma (i.e., immediately after the `1` in `age < 12 ~ 1`.\n  \n  - Notice that the second two-sided formula is actually testing two conditions. First, it tests whether or not the value of age is greater than or equal to 12. Then, it tests whether or not the value of age is less than 18.\n  \n  - Because we separated the two conditions with the and operator (`&`), both must be TRUE for `case_when()` to return the value `2`. Otherwise, it will move on to the next two-sided formula.\n  \n  - Above, the first value in `age` is `15`. `15` is _NOT_ less than `12`. So, `case_when()` moves on to evaluate the next two-sided formula. `15` is greater than or equal to `12` _AND_ `15` is less than `18`. Because both conditions of the second two-sided formula were met, `case-when()` returns the value on the right-hand side of the second two-sided formula -- `2`. So, the first value returned by the `case_when()` function is `2`. \n  \n  - The second value in `age` is `19`. `19` is _NOT_ less than `12`. So, `case_when()` moves on to evaluate the next two-sided formula. `19` is greater than or equal to `12`, but `19` is _NOT_ less than `18`. So, `case_when()` tries to move on to the next two-sided formula. However, there is no next two-sided formula. So, the second value returned by the `case_when()` function is `NA`.\n\n  -  The fourth value in `age` is `3`. `3` is less than `12`. So, the fourth value returned by the `case_when()` function is `1`. **At this point, because a condition was met, `case_when()` does not continue checking the current value of `age` against the remaining two-sided formulas. It returns a `1` and moves on to the next value of `age`.**\n  \n  - Finally, after the `case_when()` function has tested all conditions, the returned values are assigned to a new column that we named `age_3cat`.\n  \n* In everyday speech, we may express the second two-sided condition above as \"categorize all people between the ages of 12 and 18 as an adolescent.\" we want to make two points about that before moving on.\n\n  - First, while that statement may be totally reasonable in everyday speech, it isn't quite specific enough for what we are trying to do here. \"Between 12 and 18\" is a little bit ambiguous. What category is a person put in if they are exactly 12? What category are they put in if they are exactly 18? So, clearly we need to be more precise. We're not aware of any hard and fast rules for making these kinds of decisions about categorization, but we tend to _include_ the lower end of the range in the current category and _exclude_ the value on the upper end of the range in the current category. So, in the example above, we would say, \"categorize all people between the ages of 12 and less than 18 as an adolescent.\"\n  \n  - Second, when we are testing for a \"between\" condition like this one, we often see students write code like this: `age >= 12 & < 18`. R won't understand that. We have to use the column name in each condition to be tested (i.e., `age >= 12 & age < 18`), even though it doesn't change. Otherwise, we get an error that looks something like this:\n  \n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n\n```\nError in parse(text = input): <text>:5:19: unexpected '<'\n4:       age < 12             ~ 1,\n5:       age >= 12 & <\n                     ^\n```\n\n\n:::\n:::\n\n\n\n\n\n\nOk, let's go ahead and wrap up this age category variable:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 3\n      id   age age_3cat\n   <int> <int>    <dbl>\n 1     1    15        2\n 2     2    19        3\n 3     3    14        2\n 4     4     3        1\n 5     5    10        1\n 6     6    18        3\n 7     7    22        3\n 8     8    11        1\n 9     9     5        1\n10    10    NA       NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `case_when()` function to create a new column in our data frame (`age_3cat`) that categorized each participant into one of 3 categories depending on their continuous age value.\n\n## case_when() is lazy\n\nWhat do we mean when we say that `case_when()` is lazy? Well, it may not have registered when we mentioned it above, but `case_when()` stops evaluating two-sided functions for a value as soon as it finds one that is `TRUE`. For example:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 1\n  number\n   <dbl>\n1      1\n2      2\n3      3\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  number size  \n   <dbl> <chr> \n1      1 Small \n2      2 Medium\n3      3 Large \n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhy wasn't the value for the `size` column `Large` in every row of the data frame? After all, `1`, `2`, and `3` are all less than `4`, and `number < 4` was the final possible two-sided formula that could have been evaluated for each value of `number`. The answer is that `case_when()` is lazy. The first value in `number` is `1`. `1` is less than `2`. So, the condition in the first two-sided formula evaluates to `TRUE`. So, `case_when()` immediately returns the value on the right-hand side (`Small`) and **does not continue checking two-sided formulas. It moves on to the next value of `number`.**\n\nThe fact that `case_when()` is lazy isn't a bad thing. It's just something to be aware of. In fact, we can often use it to our advantage. For example, we can use `case_when()`'s laziness to rewrite the `age_3cat` code from above a little more succinctly:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 3\n      id   age age_3cat\n   <int> <int>    <dbl>\n 1     1    15        2\n 2     2    19        3\n 3     3    14        2\n 4     4     3        1\n 5     5    10        1\n 6     6    18        3\n 7     7    22        3\n 8     8    11        1\n 9     9     5        1\n10    10    NA       NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* Because `case_when()` is lazy, we were able to omit the `age >= 12` condition from the second two-sided formula. It's unnecessary because the value `1` is immediately returned for every person with an `age` value less than `12`. By definition, any value being evaluated in the second two-sided function (`age < 18`) has an age value greater than",
    "supporting": [
      "conditional_operations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}