{
  "hash": "3227a2135cb3f201c76c4841284471fe",
  "result": {
    "engine": "knitr",
    "markdown": "# Creating and Modifying Columns\n\n<!--\nDollar sign notation\nBracket notation\nmutate\n\nI start with dollar sign and bracket because they were exposed to those before \nmutate already in the book.\n-->\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nTwo of the most fundamental data management tasks are to create new columns in your data frame and to modify existing columns in your data frame. In fact, we've already talked about creating and modifying columns at a few different places in the book. \n\nIn this book, we are actually going to learn 4 different methods for creating and modifying columns of a data frame. They are:\n\n1. Using name-value pairs to add columns to a data frame during its initial creation. This was one of the first methods we used in this book for creating columns in a data frame. However, this method does not apply to creating or modifying columns in _a data frame that already exists_. Therefore, we won't discuss it much in this chapter.\n\n2. Dollar sign notation. This is probably the most commonly used base R way of creating and modifying columns in a data frame. In this book, we won't use it as much as we use `dplyr::mutate()`, but you will see it all over the place in the R community.\n\n3. Bracket notation. Again, we won't use bracket notation very often in this book. However, we will use it later on when we learn about [for loops](../writing_for_loops/writing_for_loops.qmd). Therefore, we're going to introduce you to using bracket notation to create and modify data frame columns now.\n\n4. The `mutate()` function from the `dplyr` package. This is the method that we will use the vast majority of the time in this book (and in our real-life projects). We're going to recommend that you do the same.\n\n## Creating data frames\n\nVery early on, in the [Let's get programming](../lets_get_programming/lets_get_programming.qmd) chapter, we learned how to create data frame columns using name-value pairs passed directly into the `tibble()` function.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  names heights\n  <chr>   <dbl>\n1 John       68\n2 Sally      63\n3 Brad       71\n4 Anne       72\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis is an absolutely fundamental R programming skill, and one that you will likely use often. However, most people would not consider this to be a \"data management\" task, which is the focus of this part of the book. Further, we've really already covered all we need to cover about creating columns this way. So, we're not going to write anything further about this method.\n\n## Dollar sign notation\n\nLater in the [Let's get programming](../lets_get_programming/lets_get_programming.qmd) chapter, we learned about **dollar sign notation**. At that time, we used dollar sign notation to access or \"get\" values from a column.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 68 63 71 72\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHowever, we can also use dollar sign notation to create and/or modify columns in our data frame. For example:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  names heights\n  <chr>   <dbl>\n1 John     5.67\n2 Sally    5.25\n3 Brad     5.92\n4 Anne     6   \n```\n\n\n:::\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we modified the values in the `heights` column of our `class` data frame using dollar sign notation. More specifically, we converted the values in the `heights` column from inches to feet. We did this by telling R to \"get\" the values for the `heights` column and divide them by 12 (`class$heights / 12`) and then assign those new values back to the `heights` column (`class$heights <-`). In this case, that has the effect of modifying the values of a column that already exists.\n\n::: {.callout-note}\n🗒**Side Note:** we would actually suggest that you don't typically do what we just did above in a real-world analysis. It's typically safer to create a new variable with the modified values (e.g. `height_feet`) and leave the original values in the original variable as-is.\n:::\n\nwe can also create a _new_ variable in our data frame in a similar way. All we have to do is use a valid column name (that doesn't already exist in the data frame) on the left side of our assignment arrow. For example:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  names heights grades\n  <chr>   <dbl>  <dbl>\n1 John     5.67     89\n2 Sally    5.25     92\n3 Brad     5.92     86\n4 Anne     6        98\n```\n\n\n:::\n:::\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we created a new column in our `class` data frame using dollar sign notation. We assigned the values 89, 92, 86, and 98 to that column with the assignment arrow.\n\n## Bracket notation\n\nwe also learned how to access or \"get\" values from a column using bracket notation in the [Let's get programming](../lets_get_programming/lets_get_programming.qmd) chapter. There, we actually used a combination of dollar sign and bracket notation to access single individual values from a data frame column. For example:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.916667\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut, we can also use bracket notation to access or \"get\" the entire column. For example:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.666667 5.250000 5.916667 6.000000\n```\n\n\n:::\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we used bracket notation to get all of the values from the `heights` column of the `class` data frame.\n\nwe'd like you to notice a couple of things about the example above. First, notice that this is the exact same result we got from (`class$heights`). Well, technically, the heights are now in feet instead of inches, but you know what we mean. R returned a numeric vector containing the values from the `heights` column to us. Second, notice that we used double brackets (i.e., two brackets on each side of the column name), and that the column name is wrapped in quotation marks. Both are required to get this result. \n\nSimilar to dollar sign notation, we can also create and/or modify columns in our data frame using bracket notation. For example, let's convert those heights back to inches using bracket notation:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  names heights grades\n  <chr>   <dbl>  <dbl>\n1 John       68     89\n2 Sally      63     92\n3 Brad       71     86\n4 Anne       72     98\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd, let's go ahead and add one more variable to our data frame using bracket notation.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  names heights grades  rank\n  <chr>   <dbl>  <dbl> <dbl>\n1 John       68     89     3\n2 Sally      63     92     2\n3 Brad       71     86     4\n4 Anne       72     98     1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSomewhat confusingly, we can also access, create, and modify data frame columns using single brackets. For example:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 1\n  heights\n    <dbl>\n1      68\n2      63\n3      71\n4      72\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice, however, that this returns a different result than `class$heights` and `class[[\"heights]]`. The results returned from `class$heights` and `class[[\"heights]]` were numeric vectors with 4 elements. The result returned from `class[\"heights\"]` was a data frame with 1 column and 4 rows. \n\nwe don't want you to get too hung up on the difference between single and double brackets right now. As we said, we are primarily going to use `mutate()` to create and modify data frame columns in this book. For now, it's enough for you to simply be aware that single brackets and double brackets are a thing, and they can sometimes return different results. We will make sure to point out whether or not that matters when we use bracket notation later in the book.\n\n## Modify individual values\n\nBefore moving on to the `mutate()` function, we wanted to quickly discuss using dollar sign and bracket notation for modifying individual values in a column. Recall that we already learned how to access individual column values in the [Let's get programming](../lets_get_programming/lets_get_programming.qmd) chapter.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 71\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAs you may have guessed, we can also get the result above using only bracket notation. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 71\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNot only can we use these methods to get individual values from a column in a data frame, but we can also use these methods to _modify_ an individual value in a column of a data frame. When might we want to do this? Well, we generally do this in one of two different circumstances. \n\n* First, we may do this when we're writing our own R functions (you'll learn how to do this later) and we want to make sure the function still behaves in the way we intended when there are small changes to the data. So, we may add a missing value to a column or something like that. \n\n* The second circumstance is when there are little one-off typos in the data. For example, let's say we imported a data frame that looked like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n     id site \n  <dbl> <chr>\n1     1 TX   \n2     2 CA   \n3     3 tx   \n4     4 CA   \n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice that `tx` in the third row of data isn't capitalized. Remember, R is a case-sensitive language, so this will likely cause us problems down the road if we don't fix it. The easiest way to do so is probably:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n     id site \n  <dbl> <chr>\n1     1 TX   \n2     2 CA   \n3     3 TX   \n4     4 CA   \n```\n\n\n:::\n:::\n\n\n\n\n\n\nKeep in mind that we said that we fix _little one-off typos_. If we needed to change `tx` to `TX` in multiple different places in the data, we wouldn't use this method. Instead, we would use a [conditional operation](../conditional_operations/conditional_operations.qmd), which we will discuss later in the book.\n\n## The mutate() function\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nwe first discussed `mutate()` in the [chapter on exporting data](../exporting_data_to_disk/exporting_data_to_disk.qmd), and again in the [Introduction to data management chapter](../intro_data_management/introduction.qmd). As we said there, the first two arguments to `mutate()` are `.data` and `...`. \n\nThe value passed to `.data` should always be a data frame. In this book, we will often pass data frames to the `.data` argument using the pipe operator (e.g., `df %>% mutate()`). \n\nThe value passed to the `...` argument should be a name-value pair or multiple name value pairs separated by commas. The `...` argument is where you will tell `mutate()` to create or modify columns in your data frame and how.\n\n* Name-value pairs look like this: `column name = value`.  The only thing that distinguishes whether you are creating or modifying a column is the column name in the name-value pair. If the column name in the name-value pair matches the name of an existing column in the data frame, then `mutate()` will modify that existing column. If the column name in the name-value pair does NOT match the name of an existing column in the data frame, then `mutate()` will create a _new_ column in the data frame with a matching column name. \n\nLet's take a look at a couple of examples. To get us started, let's simulate some data that is a little more interesting than the class data we used above.\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we are simulating some drug trial data that includes the following variables:\n\n  - id: Study id, there are 20 people enrolled in the trial.\n  \n  - year: Follow-up year, 0 = baseline, 1 = year one, 2 = year two.\n  \n  - age: Participant age a baseline. Must be between the ages of 35 and 75 at baseline to be eligible for the study.\n  \n  - drug: Drug the participant received, Placebo or active.\n  \n  - se_headache: Reported headaches side effect, Y/N.\n  \n  - se_diarrhea: Report diarrhea side effect, Y/N.\n  \n  - se_dry_mouth: Report dry mouth side effect, Y/N.\n  \n  - mi: Participant had myocardial infarction in study year, Y/N.\n  \n* we used the `tibble()` function above to create our data frame instead of the `data.frame()` function. This allows us to pass the `drug` column as a value to the `if_else()` function when we create `se_headache`, `se_diarrhea`, `se_dry_mouth`, and `mi`. If we had used `data.frame()` instead, we would have had to create `se_headache`, `se_diarrhea`, `se_dry_mouth`, and `mi` in a separate step.\n\n* we used a new function, `if_else()`, above to help us simulate this data. This function allows us to do something called **conditional operations**. There will be an entire chapter on [conditional operations](../conditional_operations/conditional_operations.qmd) later in the book.\n\n* we used a new function, `sample()`, above to help us simulate this data. We used this function to randomly assign values to `age`, `drug`, `se_headache`, `se_diarrhea`, `se_dry_mouth`, and `mi` instead of manually assigning each value ourselves.\n\n  - You can type `?sample` into your R console to view the help documentation for this function and follow along with the explanation below.\n  \n  - The first argument to the `sample()` function is the `x` argument. You should pass a vector of values you want R to randomly choose from. For example, we told R to select values from a vector of numbers that spanned between 35 and 75 to fill-in the `age` column. Alternatively, we told R to select values from a character vector that included the values \"Placebo\" and \"Active\" to fill-in the `drug` column.\n  \n  - The second argument to the `sample()` function is the `size` argument. You should pass a number to the size argument. That number tells R how many times to choose a value from the vector of possible values passed to the `x` argument.\n  \n  - The third argument to the `sample()` function is the `replace` argument. The default value passed to the `replace` argument is `FALSE`. This tells R that once it has chosen a value from the vector of possible values passed to the `x` argument, it can't choose that value again. If you want R to be able to choose the same value more than once, then you have to pass the value `TRUE` to the `replace` argument.\n  \n  - The fourth argument to the `sample()` function is the `prob` argument. The default value passed to the `prob` argument is `NULL`. This just means that this argument is _optional_. Passing a vector of probabilities to this argument allows you to adjust how likely it is that R will choose certain values from the vector of possible values passed to the `x` argument.\n  \n  - Finally, notice that we also used the `set.seed()` function at the very top of the code chunk. We did this because, the `sample()` function chooses values at random. That means, every time we run the code above, we get different values. That makes it difficult for me to write about the data because it's constantly changing. When we use the `set.seed()` function, the values will still be randomly selected, but they will be the _same_ randomly selected values every time. It doesn't matter what numbers you pass to the `set.seed()` function as long as you pass the same numbers every time you want to get the same random values. For example:\n  \n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  5 29 50 70 74 26 73 11  6 96\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 76 83 91 56 96 27 94 68 88 28\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 35 38 85 27 25 78 31 73 79 90\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 35 38 85 27 25 78 31 73 79 90\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  45  12  42  26  99  37 100  43  67  70\n```\n\n\n:::\n:::\n\n\n\n\n\n\n* It's not important that you fully understand the `sample()` function at this point. We're just including it for those of you who are interested in simulating some slightly more complex data than we have simulated so far. The rest of you can just copy and paste the code if you want to follow along.\n\n### Adding or modifying a single column\n\nThis is probably the simplest case of adding a new column. We are going to use `mutate()` to add a single new column to the `drug_trial` data frame. Let's say we want to add a column called `complete` that is equal to `1` if the participant showed up for all follow-up visits and equal to `0` if they didn't. In this case, we simulated our data in such a way that we have complete follow-up for every participant. So, the value for complete should be `0` in all 60 rows of the data frame. We can do this in a few different ways.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi complete\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>    <dbl>\n 1     1     0    65 Active            0           1            1     0        0\n 2     1     1    65 Active            1           1            1     0        0\n 3     1     2    65 Active            1           1            0     0        0\n 4     2     0    49 Active            1           1            1     0        0\n 5     2     1    49 Active            0           0            1     0        0\n 6     2     2    49 Active            1           1            1     0        0\n 7     3     0    48 Placebo           0           0            0     0        0\n 8     3     1    48 Placebo           0           0            0     0        0\n 9     3     2    48 Placebo           0           0            0     0        0\n10     4     0    37 Placebo           0           0            0     0        0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSo, that works, but typing that out is no fun. Not to mention, this isn't scalable at all. What if we needed 1,000 zeros? There's actually a much easier way to get the result above, which may surprise you. Take a look 👀:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi complete\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>    <dbl>\n 1     1     0    65 Active            0           1            1     0        0\n 2     1     1    65 Active            1           1            1     0        0\n 3     1     2    65 Active            1           1            0     0        0\n 4     2     0    49 Active            1           1            1     0        0\n 5     2     1    49 Active            0           0            1     0        0\n 6     2     2    49 Active            1           1            1     0        0\n 7     3     0    48 Placebo           0           0            0     0        0\n 8     3     1    48 Placebo           0           0            0     0        0\n 9     3     2    48 Placebo           0           0            0     0        0\n10     4     0    37 Placebo           0           0            0     0        0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHow easy is that? Just pass the value to the name-value pair once and R will use it in every row. This works because of something called the recycling rules ♻️. In a nutshell, this means that R will change the length of vectors in certain situations all by itself when it thinks it knows what you \"meant.\" So, above we passed gave R a length 1 vector `0` (i.e. a numeric vector with one value in it), and R changed it to a length 60 vector behind the scenes so that it could complete the operation it thought you were trying to complete. \n\n### Recycling rules\n\n♻️The recycling rules work as long as the length of the longer vector is an integer multiple of the length of the shorter vector. For example, every vector (column) in R data frames must have the same length. In this case, 60. The length of the value we used in the name-value pair above was 1 (i.e., a single `0`). Therefore, the longer vector had a length of 60 and the shorter vector had a length of 1. Because 60 * 1 = But, what if we had tried to pass the values 0 and 1 to the column instead of just zero?\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n\n```\nError in `mutate()`:\nℹ In argument: `complete = c(0, 1)`.\nCaused by error:\n! `complete` must be size 60 or 1, not 2.\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis doesn't work, but it actually isn't for the reason you may be thinking. Because 30 * 2 = 60, the length of the longer vector (60) is an integer multiple (30) of the length of the shorter vector (2). However, `tidyverse` functions throw errors when you try to recycle anything other than a single number. They are designed this way to protect you from accidentally getting unexpected results. So, we're going to switch back over to using base R to round out our discussion of the recycling rules. Let's try our example above again using base R:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n\n```\nError in `$<-`:\n! Assigned data `c(0, 1)` must be compatible with existing data.\n✖ Existing data has 60 rows.\n✖ Assigned data has 2 rows.\nℹ Only vectors of size 1 are recycled.\nCaused by error in `vectbl_recycle_rhs_rows()`:\n! Can't recycle input of size 2 to size 60.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 8\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>\n 1     1     0    65 Active            0           1            1     0\n 2     1     1    65 Active            1           1            1     0\n 3     1     2    65 Active            1           1            0     0\n 4     2     0    49 Active            1           1            1     0\n 5     2     1    49 Active            0           0            1     0\n 6     2     2    49 Active            1           1            1     0\n 7     3     0    48 Placebo           0           0            0     0\n 8     3     1    48 Placebo           0           0            0     0\n 9     3     2    48 Placebo           0           0            0     0\n10     4     0    37 Placebo           0           0            0     0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWait, why are we still getting an error? Well, take a look at the output below and see if you can figure it out.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIt may not be totally obvious, but this is telling us that `drug_trial` is a tibble -- an enhanced data frame. Remember, we created `drug_trial` using the `tibble()` function instead of the `tibble()` function. Because tibbles are part of the `tidyverse` they throw the same recycling errors that the `mutate()` function did above. So, we'll need to create a non-tibble version of `drug_trial` to finish our discussion of recycling rules.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThere we go! A regular old data frame. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n   id year age    drug se_headache se_diarrhea se_dry_mouth mi complete\n1   1    0  65  Active           0           1            1  0        0\n2   1    1  65  Active           1           1            1  0        1\n3   1    2  65  Active           1           1            0  0        0\n4   2    0  49  Active           1           1            1  0        1\n5   2    1  49  Active           0           0            1  0        0\n6   2    2  49  Active           1           1            1  0        1\n7   3    0  48 Placebo           0           0            0  0        0\n8   3    1  48 Placebo           0           0            0  0        1\n9   3    2  48 Placebo           0           0            0  0        0\n10  4    0  37 Placebo           0           0            0  0        1\n11  4    1  37 Placebo           0           0            0  0        0\n12  4    2  37 Placebo           0           0            0  1        1\n13  5    0  71 Placebo           0           0            0  0        0\n14  5    1  71 Placebo           0           0            0  0        1\n15  5    2  71 Placebo           0           0            0  0        0\n16  6    0  48 Placebo           0           0            0  0        1\n17  6    1  48 Placebo           0           0            0  1        0\n18  6    2  48 Placebo           0           0            0  1        1\n19  7    0  59  Active           1           1            1  0        0\n20  7    1  59  Active           1           1            0  0        1\n21  7    2  59  Active           1           1            1  0        0\n22  8    0  60 Placebo           0           0            0  0        1\n23  8    1  60 Placebo           0           0            0  0        0\n24  8    2  60 Placebo           0           0            0  0        1\n25  9    0  61  Active           1           1            1  0        0\n26  9    1  61  Active           0           1            1  0        1\n27  9    2  61  Active           1           0            0  0        0\n28 10    0  39  Active           1           0            1  0        1\n29 10    1  39  Active           1           0            0  0        0\n30 10    2  39  Active           1           1            1  0        1\n31 11    0  61 Placebo           0           0            0  0        0\n32 11    1  61 Placebo           0           0            0  1        1\n33 11    2  61 Placebo           0           0            0  0        0\n34 12    0  62 Placebo           1           0            1  0        1\n35 12    1  62 Placebo           0           0            0  0        0\n36 12    2  62 Placebo           0           0            0  0        1\n37 13    0  43 Placebo           0           0            0  0        0\n38 13    1  43 Placebo           0           0            0  0        1\n39 13    2  43 Placebo           0           0            0  0        0\n40 14    0  63 Placebo           0           0            0  0        1\n41 14    1  63 Placebo           0           0            0  0        0\n42 14    2  63 Placebo           0           0            0  0        1\n43 15    0  69  Active           1           1            1  0        0\n44 15    1  69  Active           1           0            1  0        1\n45 15    2  69  Active           1           1            1  0        0\n46 16    0  42 Placebo           0           0            0  0        1\n47 16    1  42 Placebo           0           0            1  0        0\n48 16    2  42 Placebo           0           0            0  1        1\n49 17    0  60 Placebo           0           0            0  0        0\n50 17    1  60 Placebo           0           0            0  0        1\n51 17    2  60 Placebo           1           0            0  0        0\n52 18    0  41  Active           1           1            1  0        1\n53 18    1  41  Active           1           1            1  0        0\n54 18    2  41  Active           1           1            0  1        1\n55 19    0  43 Placebo           0           0            0  0        0\n56 19    1  43 Placebo           0           0            0  0        1\n57 19    2  43 Placebo           0           0            0  0        0\n58 20    0  53 Placebo           0           0            0  0        1\n59 20    1  53 Placebo           0           0            0  0        0\n60 20    2  53 Placebo           0           0            0  0        1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAs you can see, the values 0 and 1 are now recycled as expected. Because 30 * 2 = 60, the length of the longer vector (60) is an integer multiple (30) of the length of the shorter vector (2). Now, what happens in a situation where the length of the longer vector is _not_ an integer multiple of the length of the shorter vector.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n\n```\nError in `$<-.data.frame`(`*tmp*`, complete, value = c(0, 1, 2, 3, 4, : replacement has 7 rows, data has 60\n```\n\n\n:::\n:::\n\n\n\n\n\n\n60 / 7 = 8.571429 -- not an integer. Because there is no integer value that we can multiply by 7 to get the number 60, R throws us an error telling us that it isn't able to use the recycling rules.\n\nFinally, the recycling rules don't only apply to creating new data frame columns. It applies in all cases where R is using two vectors to perform an operation. For example, R uses the recycling rules in mathematical operations.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n\n\n\nTo demonstrate, we create a simple numeric vector above. This vector just contains the numbers 1 through 10. Now, we can add 1 to each of those numbers like so:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  3  4  5  6  7  8  9 10 11\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice how R used the recycling rules to add 1 to every number in the `nums` vector. We didn't have to explicitly tell R to add 1 to each number. This is sometimes referred to as **vectorization**. Functions that perform an action on _all_ elements of a vector, rather than having to be explicitly programmed to perform an action on _each_ element of a vector, is a **vectorized** function. Remember, that mathematical operators -- including `+` -- _are functions_ in R. More specifically, `+` is a **vectorized** function. In fact, most built-in R functions are vectorized. Why are we telling you this? It isn't intended to confuse you, but when I was learning R I came across this term all the time in R resources and help pages, and I had no idea what it meant. We hope that this very simple example above makes it easy to understand what vectorization means, and you won't be intimidated when it pops up while you’re trying to get help with your R programs.\n\nOk, so what happens when we add a longer vector and a shorter vector?\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  4  6  6  8  8 10 10 12\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAs expected, R uses the recycling rules to change the length of the short vector to match the length of the longer vector, and then performs the operation -- in this case, addition. So, the net result is 1 + 1 = `2`, 2 + 2 = `4`, 3 + 1 = `4`, 4 + 2 = `6`, etc. You probably already guessed what's going to happen if we try to add a length 3 vector to `nums`, but let's go ahead and take a look for the sake of completeness:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in nums + c(1, 2, 3): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  5  7  9  8 10 12 11\n```\n\n\n:::\n:::\n\n\n\n\n\n\nYep, we get an error. 10 / 3 = 3.333333 -- not an integer. Because there is no integer value that we can multiply by 3 to get the number 10, R throws us an error telling us that it isn't able to use the recycling rules.\n\nNow that you understand R's recycling rules, let's return to our motivating example.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi complete\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>    <dbl>\n 1     1     0    65 Active            0           1            1     0        0\n 2     1     1    65 Active            1           1            1     0        0\n 3     1     2    65 Active            1           1            0     0        0\n 4     2     0    49 Active            1           1            1     0        0\n 5     2     1    49 Active            0           0            1     0        0\n 6     2     2    49 Active            1           1            1     0        0\n 7     3     0    48 Placebo           0           0            0     0        0\n 8     3     1    48 Placebo           0           0            0     0        0\n 9     3     2    48 Placebo           0           0            0     0        0\n10     4     0    37 Placebo           0           0            0     0        0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis method works, but not always. And, it can sometimes give us intended results. You may have originally thought to yourself, \"we've already learned the `rep()` function. Let's use that.\" In fact, that's a great idea!\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi complete\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>    <dbl>\n 1     1     0    65 Active            0           1            1     0        0\n 2     1     1    65 Active            1           1            1     0        0\n 3     1     2    65 Active            1           1            0     0        0\n 4     2     0    49 Active            1           1            1     0        0\n 5     2     1    49 Active            0           0            1     0        0\n 6     2     2    49 Active            1           1            1     0        0\n 7     3     0    48 Placebo           0           0            0     0        0\n 8     3     1    48 Placebo           0           0            0     0        0\n 9     3     2    48 Placebo           0           0            0     0        0\n10     4     0    37 Placebo           0           0            0     0        0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThat's a lot less typing than the first method we tried, and it also has the added benefit of providing code that is easier for humans to read. We can both look at the code we used in the first method and tell that there are a bunch of zeros, but it's hard to guess exactly how many, and it's hard to feel completely confident that there isn't a 1 in there somewhere that our eyes are missing. By contrast, it's easy to look at `rep(0, 60)` and know that there are exactly 60 zeros, and only 60 zeros.\n\n### Using existing variables in name-value pairs\n\nIn the example above, we create a new column called `complete` by directly supplying values for that column in the name-value pair. In our experience, it is probably more common to create new columns in our data frames by combining or transforming the values of columns that already exist in our data frame. You've already seen an example of doing so when [we created factor versions of variables](../lets_get_programming/lets_get_programming.qmd). As an additional example, we could create a factor version of our `mi` variable like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi mi_f \n   <int> <int> <int> <chr>         <int>       <int>        <int> <int> <fct>\n 1     1     0    65 Active            0           1            1     0 No   \n 2     1     1    65 Active            1           1            1     0 No   \n 3     1     2    65 Active            1           1            0     0 No   \n 4     2     0    49 Active            1           1            1     0 No   \n 5     2     1    49 Active            0           0            1     0 No   \n 6     2     2    49 Active            1           1            1     0 No   \n 7     3     0    48 Placebo           0           0            0     0 No   \n 8     3     1    48 Placebo           0           0            0     0 No   \n 9     3     2    48 Placebo           0           0            0     0 No   \n10     4     0    37 Placebo           0           0            0     0 No   \n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice that in the code above, we didn't tell R what values to use for `mi_f` by typing them explicitly in the name-value pair. Instead, we told R to go get the values of the column `mi`, do some stuff to those values, and then assign those modified values to a column in the data frame and name that column `mi_f`. \n\nHere's another example. It’s common to mean-center numeric values for many different kinds of analyses. For example, this is often done in regression analysis to aid in the interpretation of regression coefficients. We can easily mean-center numeric variables inside our `mutate()` function like so:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug  se_headache se_diarrhea se_dry_mouth    mi age_center\n   <int> <int> <int> <chr>       <int>       <int>        <int> <int>      <dbl>\n 1     1     0    65 Acti…           0           1            1     0       11.3\n 2     1     1    65 Acti…           1           1            1     0       11.3\n 3     1     2    65 Acti…           1           1            0     0       11.3\n 4     2     0    49 Acti…           1           1            1     0       -4.7\n 5     2     1    49 Acti…           0           0            1     0       -4.7\n 6     2     2    49 Acti…           1           1            1     0       -4.7\n 7     3     0    48 Plac…           0           0            0     0       -5.7\n 8     3     1    48 Plac…           0           0            0     0       -5.7\n 9     3     2    48 Plac…           0           0            0     0       -5.7\n10     4     0    37 Plac…           0           0            0     0      -16.7\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice how succinctly we were able to express this fairly complicated task. We had to figure out the find the mean of the variable `age` in the `drug_trial` data frame, subtract that value from the value for `age` in each row of the data frame, and then create a new column in the data frame containing the mean-centered values. Because of the fact that `mutate()`'s name-value pairs can accept complex expressions a value, and because all of the functions used in the code above are vectorized, we can perform this task using only a single, easy-to-read line of code (`age_center = age - mean(age)`).\n\n### Adding or modifying multiple columns\n\nIn all of the examples above, we passed a single name-value pair to the `...` argument of the `mutate()` function. If we want to create or modify multiple columns, we don't need to keep typing the `mutate()` function over and over. We can simply pass multiple name-value pairs, separated by columns, to the `...` argument. And, there is no limit to the number of pairs we can pass. This is part of the beauty of the `...` argument in R. For example, we have three variables in `drug_trial` that capture information about whether or not the participant reported side effects including headache, diarrhea, and dry mouth. Currently, those are all stored as integer vectors that can take the values `0` and `1`. Let's say that we want to also create factor versions of those vectors:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 11\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>\n 1     1     0    65 Active            0           1            1     0\n 2     1     1    65 Active            1           1            1     0\n 3     1     2    65 Active            1           1            0     0\n 4     2     0    49 Active            1           1            1     0\n 5     2     1    49 Active            0           0            1     0\n 6     2     2    49 Active            1           1            1     0\n 7     3     0    48 Placebo           0           0            0     0\n 8     3     1    48 Placebo           0           0            0     0\n 9     3     2    48 Placebo           0           0            0     0\n10     4     0    37 Placebo           0           0            0     0\n# ℹ 50 more rows\n# ℹ 3 more variables: se_headache_f <fct>, se_diarrhea_f <fct>,\n#   se_dry_mouth_f <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we created three new factor columns in the `drug_trial` data called `se_headache_f`, `se_diarrhea_f`, and `se_dry_mouth_f`.\n\n* we created all columns inside a single `mutate()` function. \n\n* Notice that we created one variable per line. We suggest you do the same. It just makes your code much easier to read.\n\nSo, adding or modifying multiple columns is really easy with `mutate()`. But, did any of you notice an error? Take a look at the structure of the data the line of code that creates `se_diarrhea_f`. Instead of writing the \"No\" label with an \"N\" and an \"o\", we accidently wrote it with an \"N\" and a zero. We find that when we have to type something over and over like this, we are more likely to make a mistake. Further, if we ever need to change the levels or labels, we will have to change them in every `factor()` function in the code above.\n\nFor these reasons (and others), programmers of many languages -- including R -- are taught [the DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself). DRY is an acronym for don't repeat yourself. We will discuss the DRY principle again in the chapter on [repeated operations](#introduction-to-repeated-operations), but for now, it just means that you typically don't want to type code that is the same (or nearly the same) over and over in your programs. Here's one way we could reduce the repetition in the code above:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 11\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>\n 1     1     0    65 Active            0           1            1     0\n 2     1     1    65 Active            1           1            1     0\n 3     1     2    65 Active            1           1            0     0\n 4     2     0    49 Active            1           1            1     0\n 5     2     1    49 Active            0           0            1     0\n 6     2     2    49 Active            1           1            1     0\n 7     3     0    48 Placebo           0           0            0     0\n 8     3     1    48 Placebo           0           0            0     0\n 9     3     2    48 Placebo           0           0            0     0\n10     4     0    37 Placebo           0           0            0     0\n# ℹ 50 more rows\n# ℹ 3 more variables: se_headache_f <fct>, se_diarrhea_f <fct>,\n#   se_dry_mouth_f <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice that in the code above we type `c(0, 1)` and `c(\"No\", \"Yes\")` once each instead of 3 times each. In the chapter on [repeated operations](../intro_repeated_operations/intro_repeated_operations.qmd) we will learn techniques for removing even more repetition from the code above.\n\n### Rowwise mutations\n\nIn all the examples above we used the values from _a single_ already existing variable in our name-value pair. However, we can also use the values from _multiple_ variables in our name-value pairs. \n\nFor example, we have three variables in our `drug_trial` data that capture information about whether or not the participant reported side effects including headache, diarrhea, and dry mouth (sounds like every drug commercial that exists 😂). What if we want to know if our participants reported _any_ side effect at each follow-up? That requires us to combine and transform data from across three different columns! This is one of those situations where there are many different ways we could accomplish this task, but we're going to use `dplyr`'s `rowwise()` function to do so in the following code:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n# Rowwise: \n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>\n 1     1     0    65 Active            0           1            1     0\n 2     1     1    65 Active            1           1            1     0\n 3     1     2    65 Active            1           1            0     0\n 4     2     0    49 Active            1           1            1     0\n 5     2     1    49 Active            0           0            1     0\n 6     2     2    49 Active            1           1            1     0\n 7     3     0    48 Placebo           0           0            0     0\n 8     3     1    48 Placebo           0           0            0     0\n 9     3     2    48 Placebo           0           0            0     0\n10     4     0    37 Placebo           0           0            0     0\n# ℹ 50 more rows\n# ℹ 1 more variable: any_se_year <lgl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we created a new column in the `drug_trial` data called `any_se_year` using the `mutate()` function.\n\n* we used the `rowwise()` function to tell R to group the data frame by rows. Said another way",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}