{
  "hash": "b59034447abd0e24d2615346caea1048",
  "result": {
    "engine": "knitr",
    "markdown": "# Creating and Modifying Columns\n\n<!--\nDollar sign notation\nBracket notation\nmutate\n\nI start with dollar sign and bracket because they were exposed to those before \nmutate already in the book.\n-->\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nTwo of the most fundamental data management tasks are to create new columns in your data frame and to modify existing columns in your data frame. In fact, we've already talked about creating and modifying columns at a few different places in the book. \n\nIn this book, we are actually going to learn 4 different methods for creating and modifying columns of a data frame. They are:\n\n1. Using name-value pairs to add columns to a data frame during its initial creation. This was one of the first methods we used in this book for creating columns in a data frame. However, this method does not apply to creating or modifying columns in _a data frame that already exists_. Therefore, we won't discuss it much in this chapter.\n\n2. Dollar sign notation. This is probably the most commonly used base R way of creating and modifying columns in a data frame. In this book, we won't use it as much as we use `dplyr::mutate()`, but you will see it all over the place in the R community.\n\n3. Bracket notation. Again, we won't use bracket notation very often in this book. However, we will use it later on when we learn about [for loops](../writing_for_loops/writing_for_loops.qmd). Therefore, we're going to introduce you to using bracket notation to create and modify data frame columns now.\n\n4. The `mutate()` function from the `dplyr` package. This is the method that we will use the vast majority of the time in this book (and in our real-life projects). We're going to recommend that you do the same.\n\n## Creating data frames\n\nVery early on, in the [Let's get programming](../lets_get_programming/lets_get_programming.qmd) chapter, we learned how to create data frame columns using name-value pairs passed directly into the `tibble()` function.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass <- tibble(\n  names   = c(\"John\", \"Sally\", \"Brad\", \"Anne\"),\n  heights = c(68, 63, 71, 72)\n)\nclass\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  names heights\n  <chr>   <dbl>\n1 John       68\n2 Sally      63\n3 Brad       71\n4 Anne       72\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis is an absolutely fundamental R programming skill, and one that you will likely use often. However, most people would not consider this to be a \"data management\" task, which is the focus of this part of the book. Further, we've really already covered all we need to cover about creating columns this way. So, we're not going to write anything further about this method.\n\n## Dollar sign notation\n\nLater in the [Let's get programming](../lets_get_programming/lets_get_programming.qmd) chapter, we learned about **dollar sign notation**. At that time, we used dollar sign notation to access or \"get\" values from a column.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass$heights\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 68 63 71 72\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHowever, we can also use dollar sign notation to create and/or modify columns in our data frame. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass$heights <- class$heights / 12\nclass\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  names heights\n  <chr>   <dbl>\n1 John     5.67\n2 Sally    5.25\n3 Brad     5.92\n4 Anne     6   \n```\n\n\n:::\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we modified the values in the `heights` column of our `class` data frame using dollar sign notation. More specifically, we converted the values in the `heights` column from inches to feet. We did this by telling R to \"get\" the values for the `heights` column and divide them by 12 (`class$heights / 12`) and then assign those new values back to the `heights` column (`class$heights <-`). In this case, that has the effect of modifying the values of a column that already exists.\n\n::: {.callout-note}\nwe would actually suggest that you don't typically do what we just did above in a real-world analysis. It's typically safer to create a new variable with the modified values (e.g. `height_feet`) and leave the original values in the original variable as-is.\n:::\n\nwe can also create a _new_ variable in our data frame in a similar way. All we have to do is use a valid column name (that doesn't already exist in the data frame) on the left side of our assignment arrow. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass$grades <- c(89, 92, 86, 98)\nclass\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  names heights grades\n  <chr>   <dbl>  <dbl>\n1 John     5.67     89\n2 Sally    5.25     92\n3 Brad     5.92     86\n4 Anne     6        98\n```\n\n\n:::\n:::\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we created a new column in our `class` data frame using dollar sign notation. We assigned the values 89, 92, 86, and 98 to that column with the assignment arrow.\n\n## Bracket notation\n\nwe also learned how to access or \"get\" values from a column using bracket notation in the [Let's get programming](../lets_get_programming/lets_get_programming.qmd) chapter. There, we actually used a combination of dollar sign and bracket notation to access single individual values from a data frame column. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass$heights[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.916667\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut, we can also use bracket notation to access or \"get\" the entire column. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass[[\"heights\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.666667 5.250000 5.916667 6.000000\n```\n\n\n:::\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we used bracket notation to get all of the values from the `heights` column of the `class` data frame.\n\nwe'd like you to notice a couple of things about the example above. First, notice that this is the exact same result we got from (`class$heights`). Well, technically, the heights are now in feet instead of inches, but you know what we mean. R returned a numeric vector containing the values from the `heights` column to us. Second, notice that we used double brackets (i.e., two brackets on each side of the column name), and that the column name is wrapped in quotation marks. Both are required to get this result. \n\nSimilar to dollar sign notation, we can also create and/or modify columns in our data frame using bracket notation. For example, let's convert those heights back to inches using bracket notation:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass[[\"heights\"]] <- class[[\"heights\"]] * 12\nclass\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  names heights grades\n  <chr>   <dbl>  <dbl>\n1 John       68     89\n2 Sally      63     92\n3 Brad       71     86\n4 Anne       72     98\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd, let's go ahead and add one more variable to our data frame using bracket notation.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass[[\"rank\"]] <- c(3, 2, 4, 1)\nclass\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  names heights grades  rank\n  <chr>   <dbl>  <dbl> <dbl>\n1 John       68     89     3\n2 Sally      63     92     2\n3 Brad       71     86     4\n4 Anne       72     98     1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSomewhat confusingly, we can also access, create, and modify data frame columns using single brackets. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass[\"heights\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 1\n  heights\n    <dbl>\n1      68\n2      63\n3      71\n4      72\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice, however, that this returns a different result than `class$heights` and `class[[\"heights]]`. The results returned from `class$heights` and `class[[\"heights]]` were numeric vectors with 4 elements. The result returned from `class[\"heights\"]` was a data frame with 1 column and 4 rows. \n\nwe don't want you to get too hung up on the difference between single and double brackets right now. As we said, we are primarily going to use `mutate()` to create and modify data frame columns in this book. For now, it's enough for you to simply be aware that single brackets and double brackets are a thing, and they can sometimes return different results. We will make sure to point out whether or not that matters when we use bracket notation later in the book.\n\n## Modify individual values\n\nBefore moving on to the `mutate()` function, we wanted to quickly discuss using dollar sign and bracket notation for modifying individual values in a column. Recall that we already learned how to access individual column values in the [Let's get programming](../lets_get_programming/lets_get_programming.qmd) chapter.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass$heights[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 71\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAs you may have guessed, we can also get the result above using only bracket notation. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass[[\"heights\"]][3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 71\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNot only can we use these methods to get individual values from a column in a data frame, but we can also use these methods to _modify_ an individual value in a column of a data frame. When might we want to do this? Well, we generally do this in one of two different circumstances. \n\n* First, we may do this when we're writing our own R functions (you'll learn how to do this later) and we want to make sure the function still behaves in the way we intended when there are small changes to the data. So, we may add a missing value to a column or something like that. \n\n* The second circumstance is when there are little one-off typos in the data. For example, let's say we imported a data frame that looked like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudy_data <- tibble(\n  id = c(1, 2, 3, 4),\n  site = c(\"TX\", \"CA\", \"tx\", \"CA\")\n)\n\nstudy_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n     id site \n  <dbl> <chr>\n1     1 TX   \n2     2 CA   \n3     3 tx   \n4     4 CA   \n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice that `tx` in the third row of data isn't capitalized. Remember, R is a case-sensitive language, so this will likely cause us problems down the road if we don't fix it. The easiest way to do so is probably:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudy_data$site[3] <- \"TX\"\nstudy_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n     id site \n  <dbl> <chr>\n1     1 TX   \n2     2 CA   \n3     3 TX   \n4     4 CA   \n```\n\n\n:::\n:::\n\n\n\n\n\n\nKeep in mind that we said that we fix _little one-off typos_. If we needed to change `tx` to `TX` in multiple different places in the data, we wouldn't use this method. Instead, we would use a [conditional operation](../conditional_operations/conditional_operations.qmd), which we will discuss later in the book.\n\n## The mutate() function\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load dplyr for the mutate function\nlibrary(dplyr)\n```\n:::\n\n\n\n\n\n\nwe first discussed `mutate()` in the [chapter on exporting data](../exporting_data_to_disk/exporting_data_to_disk.qmd), and again in the [Introduction to data management chapter](../intro_data_management/introduction.qmd). As we said there, the first two arguments to `mutate()` are `.data` and `...`. \n\nThe value passed to `.data` should always be a data frame. In this book, we will often pass data frames to the `.data` argument using the pipe operator (e.g., `df %>% mutate()`). \n\nThe value passed to the `...` argument should be a name-value pair or multiple name value pairs separated by commas. The `...` argument is where you will tell `mutate()` to create or modify columns in your data frame and how.\n\n* Name-value pairs look like this: `column name = value`.  The only thing that distinguishes whether you are creating or modifying a column is the column name in the name-value pair. If the column name in the name-value pair matches the name of an existing column in the data frame, then `mutate()` will modify that existing column. If the column name in the name-value pair does NOT match the name of an existing column in the data frame, then `mutate()` will create a _new_ column in the data frame with a matching column name. \n\nLet's take a look at a couple of examples. To get us started, let's simulate some data that is a little more interesting than the class data we used above.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\ndrug_trial <- tibble(\n  # Study id, there are 20 people enrolled in the trial.\n  id = rep(1:20, each = 3),\n  # Follow-up year, 0 = baseline, 1 = year one, 2 = year two.\n  year = rep(0:2, times = 20),\n  # Participant age a baseline. Must be between the ages of 35 and 75 at \n  # baseline to be eligible for the study\n  age = sample(35:75, 20, TRUE) %>% rep(each = 3),\n  # Drug the participant received, Placebo or active\n  drug = sample(c(\"Placebo\", \"Active\"), 20, TRUE) %>% \n    rep(each = 3),\n  # Reported headaches side effect, Y/N\n  se_headache = if_else(\n    drug == \"Placebo\", \n    sample(0:1, 60, TRUE, c(.95,.05)), \n    sample(0:1, 60, TRUE, c(.10, .90))\n  ),\n  # Report diarrhea side effect, Y/N\n  se_diarrhea = if_else(\n    drug == \"Placebo\", \n    sample(0:1, 60, TRUE, c(.98,.02)), \n    sample(0:1, 60, TRUE, c(.20, .80))\n  ),\n  # Report dry mouth side effect, Y/N\n  se_dry_mouth = if_else(\n    drug == \"Placebo\", \n    sample(0:1, 60, TRUE, c(.97,.03)), \n    sample(0:1, 60, TRUE, c(.30, .70))\n  ),\n  # Participant had myocardial infarction in study year, Y/N\n  mi = if_else(\n    drug == \"Placebo\", \n    sample(0:1, 60, TRUE, c(.85, .15)), \n    sample(0:1, 60, TRUE, c(.80, .20))\n  )\n)\n```\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we are simulating some drug trial data that includes the following variables:\n\n  - id: Study id, there are 20 people enrolled in the trial.\n  \n  - year: Follow-up year, 0 = baseline, 1 = year one, 2 = year two.\n  \n  - age: Participant age a baseline. Must be between the ages of 35 and 75 at baseline to be eligible for the study.\n  \n  - drug: Drug the participant received, Placebo or active.\n  \n  - se_headache: Reported headaches side effect, Y/N.\n  \n  - se_diarrhea: Report diarrhea side effect, Y/N.\n  \n  - se_dry_mouth: Report dry mouth side effect, Y/N.\n  \n  - mi: Participant had myocardial infarction in study year, Y/N.\n  \n* we used the `tibble()` function above to create our data frame instead of the `data.frame()` function. This allows us to pass the `drug` column as a value to the `if_else()` function when we create `se_headache`, `se_diarrhea`, `se_dry_mouth`, and `mi`. If we had used `data.frame()` instead, we would have had to create `se_headache`, `se_diarrhea`, `se_dry_mouth`, and `mi` in a separate step.\n\n* we used a new function, `if_else()`, above to help us simulate this data. This function allows us to do something called **conditional operations**. There will be an entire chapter on [conditional operations](../conditional_operations/conditional_operations.qmd) later in the book.\n\n* we used a new function, `sample()`, above to help us simulate this data. We used this function to randomly assign values to `age`, `drug`, `se_headache`, `se_diarrhea`, `se_dry_mouth`, and `mi` instead of manually assigning each value ourselves.\n\n  - You can type `?sample` into your R console to view the help documentation for this function and follow along with the explanation below.\n  \n  - The first argument to the `sample()` function is the `x` argument. You should pass a vector of values you want R to randomly choose from. For example, we told R to select values from a vector of numbers that spanned between 35 and 75 to fill-in the `age` column. Alternatively, we told R to select values from a character vector that included the values \"Placebo\" and \"Active\" to fill-in the `drug` column.\n  \n  - The second argument to the `sample()` function is the `size` argument. You should pass a number to the size argument. That number tells R how many times to choose a value from the vector of possible values passed to the `x` argument.\n  \n  - The third argument to the `sample()` function is the `replace` argument. The default value passed to the `replace` argument is `FALSE`. This tells R that once it has chosen a value from the vector of possible values passed to the `x` argument, it can't choose that value again. If you want R to be able to choose the same value more than once, then you have to pass the value `TRUE` to the `replace` argument.\n  \n  - The fourth argument to the `sample()` function is the `prob` argument. The default value passed to the `prob` argument is `NULL`. This just means that this argument is _optional_. Passing a vector of probabilities to this argument allows you to adjust how likely it is that R will choose certain values from the vector of possible values passed to the `x` argument.\n  \n  - Finally, notice that we also used the `set.seed()` function at the very top of the code chunk. We did this because, the `sample()` function chooses values at random. That means, every time we run the code above, we get different values. That makes it difficult for me to write about the data because it's constantly changing. When we use the `set.seed()` function, the values will still be randomly selected, but they will be the _same_ randomly selected values every time. It doesn't matter what numbers you pass to the `set.seed()` function as long as you pass the same numbers every time you want to get the same random values. For example:\n  \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# No set.seed - Random values\nsample(1:100, 10, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  5 29 50 70 74 26 73 11  6 96\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# No set.seed - Different random values\nsample(1:100, 10, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 76 83 91 56 96 27 94 68 88 28\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use set.seed - Random values\nset.seed(456)\nsample(1:100, 10, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 35 38 85 27 25 78 31 73 79 90\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use set.seed again - Same random values\nset.seed(456)\nsample(1:100, 10, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 35 38 85 27 25 78 31 73 79 90\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use set.seed with different value - Different random values\nset.seed(789)\nsample(1:100, 10, TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  45  12  42  26  99  37 100  43  67  70\n```\n\n\n:::\n:::\n\n\n\n\n\n\n* It's not important that you fully understand the `sample()` function at this point. We're just including it for those of you who are interested in simulating some slightly more complex data than we have simulated so far. The rest of you can just copy and paste the code if you want to follow along.\n\n### Adding or modifying a single column\n\nThis is probably the simplest case of adding a new column. We are going to use `mutate()` to add a single new column to the `drug_trial` data frame. Let's say we want to add a column called `complete` that is equal to `1` if the participant showed up for all follow-up visits and equal to `0` if they didn't. In this case, we simulated our data in such a way that we have complete follow-up for every participant. So, the value for complete should be `0` in all 60 rows of the data frame. We can do this in a few different ways.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  mutate(complete = c(\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi complete\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>    <dbl>\n 1     1     0    65 Active            0           1            1     0        0\n 2     1     1    65 Active            1           1            1     0        0\n 3     1     2    65 Active            1           1            0     0        0\n 4     2     0    49 Active            1           1            1     0        0\n 5     2     1    49 Active            0           0            1     0        0\n 6     2     2    49 Active            1           1            1     0        0\n 7     3     0    48 Placebo           0           0            0     0        0\n 8     3     1    48 Placebo           0           0            0     0        0\n 9     3     2    48 Placebo           0           0            0     0        0\n10     4     0    37 Placebo           0           0            0     0        0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSo, that works, but typing that out is no fun. Not to mention, this isn't scalable at all. What if we needed 1,000 zeros? There's actually a much easier way to get the result above, which may surprise you. Take a look 👀:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  mutate(complete = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi complete\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>    <dbl>\n 1     1     0    65 Active            0           1            1     0        0\n 2     1     1    65 Active            1           1            1     0        0\n 3     1     2    65 Active            1           1            0     0        0\n 4     2     0    49 Active            1           1            1     0        0\n 5     2     1    49 Active            0           0            1     0        0\n 6     2     2    49 Active            1           1            1     0        0\n 7     3     0    48 Placebo           0           0            0     0        0\n 8     3     1    48 Placebo           0           0            0     0        0\n 9     3     2    48 Placebo           0           0            0     0        0\n10     4     0    37 Placebo           0           0            0     0        0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHow easy is that? Just pass the value to the name-value pair once and R will use it in every row. This works because of something called the recycling rules ♻️. In a nutshell, this means that R will change the length of vectors in certain situations all by itself when it thinks it knows what you \"meant.\" So, above we passed gave R a length 1 vector `0` (i.e. a numeric vector with one value in it), and R changed it to a length 60 vector behind the scenes so that it could complete the operation it thought you were trying to complete. \n\n### Recycling rules\n\n♻️The recycling rules work as long as the length of the longer vector is an integer multiple of the length of the shorter vector. For example, every vector (column) in R data frames must have the same length. In this case, 60. The length of the value we used in the name-value pair above was 1 (i.e., a single `0`). Therefore, the longer vector had a length of 60 and the shorter vector had a length of 1. Because 60 * 1 = But, what if we had tried to pass the values 0 and 1 to the column instead of just zero?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  mutate(complete = c(0, 1))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `mutate()`:\nℹ In argument: `complete = c(0, 1)`.\nCaused by error:\n! `complete` must be size 60 or 1, not 2.\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis doesn't work, but it actually isn't for the reason you may be thinking. Because 30 * 2 = 60, the length of the longer vector (60) is an integer multiple (30) of the length of the shorter vector (2). However, `tidyverse` functions throw errors when you try to recycle anything other than a single number. They are designed this way to protect you from accidentally getting unexpected results. So, we're going to switch back over to using base R to round out our discussion of the recycling rules. Let's try our example above again using base R:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial$complete <- c(0,1)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `$<-`:\n! Assigned data `c(0, 1)` must be compatible with existing data.\n✖ Existing data has 60 rows.\n✖ Assigned data has 2 rows.\nℹ Only vectors of size 1 are recycled.\nCaused by error in `vectbl_recycle_rhs_rows()`:\n! Can't recycle input of size 2 to size 60.\n```\n\n\n:::\n\n```{.r .cell-code}\ndrug_trial\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 8\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>\n 1     1     0    65 Active            0           1            1     0\n 2     1     1    65 Active            1           1            1     0\n 3     1     2    65 Active            1           1            0     0\n 4     2     0    49 Active            1           1            1     0\n 5     2     1    49 Active            0           0            1     0\n 6     2     2    49 Active            1           1            1     0\n 7     3     0    48 Placebo           0           0            0     0\n 8     3     1    48 Placebo           0           0            0     0\n 9     3     2    48 Placebo           0           0            0     0\n10     4     0    37 Placebo           0           0            0     0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWait, why are we still getting an error? Well, take a look at the output below and see if you can figure it out.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(drug_trial)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIt may not be totally obvious, but this is telling us that `drug_trial` is a tibble -- an enhanced data frame. Remember, we created `drug_trial` using the `tibble()` function instead of the `tibble()` function. Because tibbles are part of the `tidyverse` they throw the same recycling errors that the `mutate()` function did above. So, we'll need to create a non-tibble version of `drug_trial` to finish our discussion of recycling rules.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_df <- as.data.frame(drug_trial)\nclass(drug_trial_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThere we go! A regular old data frame. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_df$complete <- c(0,1)\ndrug_trial_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   id year age    drug se_headache se_diarrhea se_dry_mouth mi complete\n1   1    0  65  Active           0           1            1  0        0\n2   1    1  65  Active           1           1            1  0        1\n3   1    2  65  Active           1           1            0  0        0\n4   2    0  49  Active           1           1            1  0        1\n5   2    1  49  Active           0           0            1  0        0\n6   2    2  49  Active           1           1            1  0        1\n7   3    0  48 Placebo           0           0            0  0        0\n8   3    1  48 Placebo           0           0            0  0        1\n9   3    2  48 Placebo           0           0            0  0        0\n10  4    0  37 Placebo           0           0            0  0        1\n11  4    1  37 Placebo           0           0            0  0        0\n12  4    2  37 Placebo           0           0            0  1        1\n13  5    0  71 Placebo           0           0            0  0        0\n14  5    1  71 Placebo           0           0            0  0        1\n15  5    2  71 Placebo           0           0            0  0        0\n16  6    0  48 Placebo           0           0            0  0        1\n17  6    1  48 Placebo           0           0            0  1        0\n18  6    2  48 Placebo           0           0            0  1        1\n19  7    0  59  Active           1           1            1  0        0\n20  7    1  59  Active           1           1            0  0        1\n21  7    2  59  Active           1           1            1  0        0\n22  8    0  60 Placebo           0           0            0  0        1\n23  8    1  60 Placebo           0           0            0  0        0\n24  8    2  60 Placebo           0           0            0  0        1\n25  9    0  61  Active           1           1            1  0        0\n26  9    1  61  Active           0           1            1  0        1\n27  9    2  61  Active           1           0            0  0        0\n28 10    0  39  Active           1           0            1  0        1\n29 10    1  39  Active           1           0            0  0        0\n30 10    2  39  Active           1           1            1  0        1\n31 11    0  61 Placebo           0           0            0  0        0\n32 11    1  61 Placebo           0           0            0  1        1\n33 11    2  61 Placebo           0           0            0  0        0\n34 12    0  62 Placebo           1           0            1  0        1\n35 12    1  62 Placebo           0           0            0  0        0\n36 12    2  62 Placebo           0           0            0  0        1\n37 13    0  43 Placebo           0           0            0  0        0\n38 13    1  43 Placebo           0           0            0  0        1\n39 13    2  43 Placebo           0           0            0  0        0\n40 14    0  63 Placebo           0           0            0  0        1\n41 14    1  63 Placebo           0           0            0  0        0\n42 14    2  63 Placebo           0           0            0  0        1\n43 15    0  69  Active           1           1            1  0        0\n44 15    1  69  Active           1           0            1  0        1\n45 15    2  69  Active           1           1            1  0        0\n46 16    0  42 Placebo           0           0            0  0        1\n47 16    1  42 Placebo           0           0            1  0        0\n48 16    2  42 Placebo           0           0            0  1        1\n49 17    0  60 Placebo           0           0            0  0        0\n50 17    1  60 Placebo           0           0            0  0        1\n51 17    2  60 Placebo           1           0            0  0        0\n52 18    0  41  Active           1           1            1  0        1\n53 18    1  41  Active           1           1            1  0        0\n54 18    2  41  Active           1           1            0  1        1\n55 19    0  43 Placebo           0           0            0  0        0\n56 19    1  43 Placebo           0           0            0  0        1\n57 19    2  43 Placebo           0           0            0  0        0\n58 20    0  53 Placebo           0           0            0  0        1\n59 20    1  53 Placebo           0           0            0  0        0\n60 20    2  53 Placebo           0           0            0  0        1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAs you can see, the values 0 and 1 are now recycled as expected. Because 30 * 2 = 60, the length of the longer vector (60) is an integer multiple (30) of the length of the shorter vector (2). Now, what happens in a situation where the length of the longer vector is _not_ an integer multiple of the length of the shorter vector.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_df$complete <- c(0, 1, 2, 3, 4, 5, 6) # 7 values\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `$<-.data.frame`(`*tmp*`, complete, value = c(0, 1, 2, 3, 4, : replacement has 7 rows, data has 60\n```\n\n\n:::\n:::\n\n\n\n\n\n\n60 / 7 = 8.571429 -- not an integer. Because there is no integer value that we can multiply by 7 to get the number 60, R throws us an error telling us that it isn't able to use the recycling rules.\n\nFinally, the recycling rules don't only apply to creating new data frame columns. It applies in all cases where R is using two vectors to perform an operation. For example, R uses the recycling rules in mathematical operations.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums <- 1:10\nnums\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\n\n\n\n\n\nTo demonstrate, we create a simple numeric vector above. This vector just contains the numbers 1 through 10. Now, we can add 1 to each of those numbers like so:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  3  4  5  6  7  8  9 10 11\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice how R used the recycling rules to add 1 to every number in the `nums` vector. We didn't have to explicitly tell R to add 1 to each number. This is sometimes referred to as **vectorization**. Functions that perform an action on _all_ elements of a vector, rather than having to be explicitly programmed to perform an action on _each_ element of a vector, is a **vectorized** function. Remember, that mathematical operators -- including `+` -- _are functions_ in R. More specifically, `+` is a **vectorized** function. In fact, most built-in R functions are vectorized. Why are we telling you this? It isn't intended to confuse you, but when I was learning R I came across this term all the time in R resources and help pages, and I had no idea what it meant. We hope that this very simple example above makes it easy to understand what vectorization means, and you won't be intimidated when it pops up while you’re trying to get help with your R programs.\n\nOk, so what happens when we add a longer vector and a shorter vector?\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums + c(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  4  6  6  8  8 10 10 12\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAs expected, R uses the recycling rules to change the length of the short vector to match the length of the longer vector, and then performs the operation -- in this case, addition. So, the net result is 1 + 1 = `2`, 2 + 2 = `4`, 3 + 1 = `4`, 4 + 2 = `6`, etc. You probably already guessed what's going to happen if we try to add a length 3 vector to `nums`, but let's go ahead and take a look for the sake of completeness:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums + c(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in nums + c(1, 2, 3): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  4  6  5  7  9  8 10 12 11\n```\n\n\n:::\n:::\n\n\n\n\n\n\nYep, we get an error. 10 / 3 = 3.333333 -- not an integer. Because there is no integer value that we can multiply by 3 to get the number 10, R throws us an error telling us that it isn't able to use the recycling rules.\n\nNow that you understand R's recycling rules, let's return to our motivating example.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  mutate(complete = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi complete\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>    <dbl>\n 1     1     0    65 Active            0           1            1     0        0\n 2     1     1    65 Active            1           1            1     0        0\n 3     1     2    65 Active            1           1            0     0        0\n 4     2     0    49 Active            1           1            1     0        0\n 5     2     1    49 Active            0           0            1     0        0\n 6     2     2    49 Active            1           1            1     0        0\n 7     3     0    48 Placebo           0           0            0     0        0\n 8     3     1    48 Placebo           0           0            0     0        0\n 9     3     2    48 Placebo           0           0            0     0        0\n10     4     0    37 Placebo           0           0            0     0        0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis method works, but not always. And, it can sometimes give us intended results. You may have originally thought to yourself, \"we've already learned the `rep()` function. Let's use that.\" In fact, that's a great idea!\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  mutate(complete = rep(0, 60))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi complete\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>    <dbl>\n 1     1     0    65 Active            0           1            1     0        0\n 2     1     1    65 Active            1           1            1     0        0\n 3     1     2    65 Active            1           1            0     0        0\n 4     2     0    49 Active            1           1            1     0        0\n 5     2     1    49 Active            0           0            1     0        0\n 6     2     2    49 Active            1           1            1     0        0\n 7     3     0    48 Placebo           0           0            0     0        0\n 8     3     1    48 Placebo           0           0            0     0        0\n 9     3     2    48 Placebo           0           0            0     0        0\n10     4     0    37 Placebo           0           0            0     0        0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThat's a lot less typing than the first method we tried, and it also has the added benefit of providing code that is easier for humans to read. We can both look at the code we used in the first method and tell that there are a bunch of zeros, but it's hard to guess exactly how many, and it's hard to feel completely confident that there isn't a 1 in there somewhere that our eyes are missing. By contrast, it's easy to look at `rep(0, 60)` and know that there are exactly 60 zeros, and only 60 zeros.\n\n### Using existing variables in name-value pairs\n\nIn the example above, we create a new column called `complete` by directly supplying values for that column in the name-value pair. In our experience, it is probably more common to create new columns in our data frames by combining or transforming the values of columns that already exist in our data frame. You've already seen an example of doing so when [we created factor versions of variables](../lets_get_programming/lets_get_programming.qmd). As an additional example, we could create a factor version of our `mi` variable like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  mutate(mi_f = factor(mi, c(0, 1), c(\"No\", \"Yes\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi mi_f \n   <int> <int> <int> <chr>         <int>       <int>        <int> <int> <fct>\n 1     1     0    65 Active            0           1            1     0 No   \n 2     1     1    65 Active            1           1            1     0 No   \n 3     1     2    65 Active            1           1            0     0 No   \n 4     2     0    49 Active            1           1            1     0 No   \n 5     2     1    49 Active            0           0            1     0 No   \n 6     2     2    49 Active            1           1            1     0 No   \n 7     3     0    48 Placebo           0           0            0     0 No   \n 8     3     1    48 Placebo           0           0            0     0 No   \n 9     3     2    48 Placebo           0           0            0     0 No   \n10     4     0    37 Placebo           0           0            0     0 No   \n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice that in the code above, we didn't tell R what values to use for `mi_f` by typing them explicitly in the name-value pair. Instead, we told R to go get the values of the column `mi`, do some stuff to those values, and then assign those modified values to a column in the data frame and name that column `mi_f`. \n\nHere's another example. It’s common to mean-center numeric values for many different kinds of analyses. For example, this is often done in regression analysis to aid in the interpretation of regression coefficients. We can easily mean-center numeric variables inside our `mutate()` function like so:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  mutate(age_center = age - mean(age))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n      id  year   age drug  se_headache se_diarrhea se_dry_mouth    mi age_center\n   <int> <int> <int> <chr>       <int>       <int>        <int> <int>      <dbl>\n 1     1     0    65 Acti…           0           1            1     0       11.3\n 2     1     1    65 Acti…           1           1            1     0       11.3\n 3     1     2    65 Acti…           1           1            0     0       11.3\n 4     2     0    49 Acti…           1           1            1     0       -4.7\n 5     2     1    49 Acti…           0           0            1     0       -4.7\n 6     2     2    49 Acti…           1           1            1     0       -4.7\n 7     3     0    48 Plac…           0           0            0     0       -5.7\n 8     3     1    48 Plac…           0           0            0     0       -5.7\n 9     3     2    48 Plac…           0           0            0     0       -5.7\n10     4     0    37 Plac…           0           0            0     0      -16.7\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice how succinctly we were able to express this fairly complicated task. We had to figure out the find the mean of the variable `age` in the `drug_trial` data frame, subtract that value from the value for `age` in each row of the data frame, and then create a new column in the data frame containing the mean-centered values. Because of the fact that `mutate()`'s name-value pairs can accept complex expressions a value, and because all of the functions used in the code above are vectorized, we can perform this task using only a single, easy-to-read line of code (`age_center = age - mean(age)`).\n\n### Adding or modifying multiple columns\n\nIn all of the examples above, we passed a single name-value pair to the `...` argument of the `mutate()` function. If we want to create or modify multiple columns, we don't need to keep typing the `mutate()` function over and over. We can simply pass multiple name-value pairs, separated by columns, to the `...` argument. And, there is no limit to the number of pairs we can pass. This is part of the beauty of the `...` argument in R. For example, we have three variables in `drug_trial` that capture information about whether or not the participant reported side effects including headache, diarrhea, and dry mouth. Currently, those are all stored as integer vectors that can take the values `0` and `1`. Let's say that we want to also create factor versions of those vectors:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  mutate(\n    se_headache_f  = factor(se_headache, c(0, 1), c(\"No\", \"Yes\")),\n    se_diarrhea_f  = factor(se_diarrhea, c(0, 1), c(\"N0\", \"Yes\")),\n    se_dry_mouth_f = factor(se_dry_mouth, c(0, 1), c(\"No\", \"Yes\"))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 11\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>\n 1     1     0    65 Active            0           1            1     0\n 2     1     1    65 Active            1           1            1     0\n 3     1     2    65 Active            1           1            0     0\n 4     2     0    49 Active            1           1            1     0\n 5     2     1    49 Active            0           0            1     0\n 6     2     2    49 Active            1           1            1     0\n 7     3     0    48 Placebo           0           0            0     0\n 8     3     1    48 Placebo           0           0            0     0\n 9     3     2    48 Placebo           0           0            0     0\n10     4     0    37 Placebo           0           0            0     0\n# ℹ 50 more rows\n# ℹ 3 more variables: se_headache_f <fct>, se_diarrhea_f <fct>,\n#   se_dry_mouth_f <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we created three new factor columns in the `drug_trial` data called `se_headache_f`, `se_diarrhea_f`, and `se_dry_mouth_f`.\n\n* we created all columns inside a single `mutate()` function. \n\n* Notice that we created one variable per line. We suggest you do the same. It just makes your code much easier to read.\n\nSo, adding or modifying multiple columns is really easy with `mutate()`. But, did any of you notice an error? Take a look at the structure of the data the line of code that creates `se_diarrhea_f`. Instead of writing the \"No\" label with an \"N\" and an \"o\", we accidently wrote it with an \"N\" and a zero. We find that when we have to type something over and over like this, we are more likely to make a mistake. Further, if we ever need to change the levels or labels, we will have to change them in every `factor()` function in the code above.\n\nFor these reasons (and others), programmers of many languages -- including R -- are taught [the DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself). DRY is an acronym for don't repeat yourself. We will discuss the DRY principle again in the chapter on [repeated operations](#introduction-to-repeated-operations), but for now, it just means that you typically don't want to type code that is the same (or nearly the same) over and over in your programs. Here's one way we could reduce the repetition in the code above:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a vector of 0/1 levels that can be reused below.\nyn_levs <- c(0, 1)\n# Create a vector of \"No\"/\"Yes\" labels that can be reused below.\nyn_labs <- c(\"No\", \"Yes\")\n\ndrug_trial %>% \n  mutate(\n    se_headache_f  = factor(se_headache, yn_levs, yn_labs),\n    se_diarrhea_f  = factor(se_diarrhea, yn_levs, yn_labs),\n    se_dry_mouth_f = factor(se_dry_mouth, yn_levs, yn_labs)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 11\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>\n 1     1     0    65 Active            0           1            1     0\n 2     1     1    65 Active            1           1            1     0\n 3     1     2    65 Active            1           1            0     0\n 4     2     0    49 Active            1           1            1     0\n 5     2     1    49 Active            0           0            1     0\n 6     2     2    49 Active            1           1            1     0\n 7     3     0    48 Placebo           0           0            0     0\n 8     3     1    48 Placebo           0           0            0     0\n 9     3     2    48 Placebo           0           0            0     0\n10     4     0    37 Placebo           0           0            0     0\n# ℹ 50 more rows\n# ℹ 3 more variables: se_headache_f <fct>, se_diarrhea_f <fct>,\n#   se_dry_mouth_f <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice that in the code above we type `c(0, 1)` and `c(\"No\", \"Yes\")` once each instead of 3 times each. In the chapter on [repeated operations](../intro_repeated_operations/intro_repeated_operations.qmd) we will learn techniques for removing even more repetition from the code above.\n\n### Rowwise mutations\n\nIn all the examples above we used the values from _a single_ already existing variable in our name-value pair. However, we can also use the values from _multiple_ variables in our name-value pairs. \n\nFor example, we have three variables in our `drug_trial` data that capture information about whether or not the participant reported side effects including headache, diarrhea, and dry mouth (sounds like every drug commercial that exists 😂). What if we want to know if our participants reported _any_ side effect at each follow-up? That requires us to combine and transform data from across three different columns! This is one of those situations where there are many different ways we could accomplish this task, but we're going to use `dplyr`'s `rowwise()` function to do so in the following code:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial %>% \n  rowwise() %>% \n  mutate(any_se_year = sum(se_headache, se_diarrhea, se_dry_mouth) > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n# Rowwise: \n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>\n 1     1     0    65 Active            0           1            1     0\n 2     1     1    65 Active            1           1            1     0\n 3     1     2    65 Active            1           1            0     0\n 4     2     0    49 Active            1           1            1     0\n 5     2     1    49 Active            0           0            1     0\n 6     2     2    49 Active            1           1            1     0\n 7     3     0    48 Placebo           0           0            0     0\n 8     3     1    48 Placebo           0           0            0     0\n 9     3     2    48 Placebo           0           0            0     0\n10     4     0    37 Placebo           0           0            0     0\n# ℹ 50 more rows\n# ℹ 1 more variable: any_se_year <lgl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* we created a new column in the `drug_trial` data called `any_se_year` using the `mutate()` function.\n\n* we used the `rowwise()` function to tell R to group the data frame by rows. Said another way `rowwise()` tells R to do any calculations that follow _across_ columns instead _within_ columns. Don't worry, there are more examples below.\n\n* The value we passed to the name-value pair inside `mutate()` was actually the result of two calculations. \n\n  - First, R summed the values of se_headache, se_diarrhea, and se_dry_mouth (i.e., `sum(se_headache, se_diarrhea, se_dry_mouth)`). \n  \n  - Next, R compared that the summed value to `0`. If the summed value was greater than 0, then the value assigned to `any_se_year` was `TRUE`. Otherwise, the value assigned to `any_se_year` was `FALSE`.\n\nBecause there is some new stuff in the code above, I'm going break it down a little bit further. We'll start with `rowwise()`. And, to reduce distractions a much as possible, I'm going to create a new data frame with only the columns we need for this example (sneak peek at the next chapter):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_sub <- drug_trial %>% \n  select(id, year, starts_with(\"se\")) %>% \n  print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 5\n      id  year se_headache se_diarrhea se_dry_mouth\n   <int> <int>       <int>       <int>        <int>\n 1     1     0           0           1            1\n 2     1     1           1           1            1\n 3     1     2           1           1            0\n 4     2     0           1           1            1\n 5     2     1           0           0            1\n 6     2     2           1           1            1\n 7     3     0           0           0            0\n 8     3     1           0           0            0\n 9     3     2           0           0            0\n10     4     0           0           0            0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLet's start by discussing what `rowwise()` does. As we discussed above, most built-in R functions are vectorized. They _do things_ to entire vectors, and data frame columns _are_ vectors. So, without using `rowwise()` the `sum()` function would have returned the value `54`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_sub %>% \n  mutate(any_se_year = sum(se_headache, se_diarrhea, se_dry_mouth))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 6\n      id  year se_headache se_diarrhea se_dry_mouth any_se_year\n   <int> <int>       <int>       <int>        <int>       <int>\n 1     1     0           0           1            1          54\n 2     1     1           1           1            1          54\n 3     1     2           1           1            0          54\n 4     2     0           1           1            1          54\n 5     2     1           0           0            1          54\n 6     2     2           1           1            1          54\n 7     3     0           0           0            0          54\n 8     3     1           0           0            0          54\n 9     3     2           0           0            0          54\n10     4     0           0           0            0          54\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAny guesses why it returns 54? Here's a hint:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(c(0, 1, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(c(1, 1, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(\n  c(0, 1, 0),\n  c(1, 1, 0)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhen we pass a single numeric vector to the `sum()` function, it adds together all the numbers in that function. When we pass two or more numeric vectors to the `sum()` function, it adds together all the numbers in all the vectors combined. Our data frame columns are no different:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(drug_trial_sub$se_headache)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(drug_trial_sub$se_diarrhea)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(drug_trial_sub$se_dry_mouth)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(\n  drug_trial_sub$se_headache,\n  drug_trial_sub$se_diarrhea,\n  drug_trial_sub$se_dry_mouth\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHopefully, you see that the `sum()` function is taking the total of all three vectors added together, which is a single number (`54`), and then using recycling rules to assign that value to every row of `any_se_year`. \n\nUsing `rowwise()` tells R to add _across_ the columns instead of _within_ the columns. So, add the first value for `se_headache` to the first value for `se_diarrhea` to the first value for `se_dry_mouth`, assign that value to the first value of `any_se_year`, and then repeat for each subsequent row. This is what that result looks like:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_sub %>% \n  rowwise() %>% \n  mutate(any_se_year = sum(se_headache, se_diarrhea, se_dry_mouth))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 6\n# Rowwise: \n      id  year se_headache se_diarrhea se_dry_mouth any_se_year\n   <int> <int>       <int>       <int>        <int>       <int>\n 1     1     0           0           1            1           2\n 2     1     1           1           1            1           3\n 3     1     2           1           1            0           2\n 4     2     0           1           1            1           3\n 5     2     1           0           0            1           1\n 6     2     2           1           1            1           3\n 7     3     0           0           0            0           0\n 8     3     1           0           0            0           0\n 9     3     2           0           0            0           0\n10     4     0           0           0            0           0\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBecause the value for each side effect could only be 0 (if not reported) or 1 (if reported) then the rowwise sum of those numbers is a count of the number of side effects reported in each row. For example, person 1 reported not having headaches (`0`), having diarrhea (`1`), and having dry mouth (`1`) at baseline (`year` == `0`). And, 0 + 1 + 1 = 2 -- the same value you see for `any_se_year` in that row. For instructional purposes, let's run the code above again, but change the name of the variable to `n_se_year` (i.e., the count of side effects a  participant reported in a given year).\n\nThis may be a useful result in and of itself. However, we said we wanted a variable that captured whether a participant reported _any_ side effect at each follow-up. Well, because `any_se_year` is currently a count of side effects reported for that participant in that year, then where the value of `any_se_year` is `0` no side effects were reported. If the current value of `any_se_year` is greater than `0`, then one or more side effects were reported. Generally, we can test inequalities like this in the following way:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Is 0 greater than 0?\n0 > 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Is 2 greater than 0?\n2 > 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIn our specific situation, instead of using a number on the left side of the inequality, we can use our calculated `n_se_year` variable values on the left side of the inequality:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_sub %>% \n  rowwise() %>% \n  mutate(\n    n_se_year   = sum(se_headache, se_diarrhea, se_dry_mouth),\n    any_se_year = n_se_year > 0\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 7\n# Rowwise: \n      id  year se_headache se_diarrhea se_dry_mouth n_se_year any_se_year\n   <int> <int>       <int>       <int>        <int>     <int> <lgl>      \n 1     1     0           0           1            1         2 TRUE       \n 2     1     1           1           1            1         3 TRUE       \n 3     1     2           1           1            0         2 TRUE       \n 4     2     0           1           1            1         3 TRUE       \n 5     2     1           0           0            1         1 TRUE       \n 6     2     2           1           1            1         3 TRUE       \n 7     3     0           0           0            0         0 FALSE      \n 8     3     1           0           0            0         0 FALSE      \n 9     3     2           0           0            0         0 FALSE      \n10     4     0           0           0            0         0 FALSE      \n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIn this way, `any_se_year` is TRUE if the participant reported any side effect in that year and false if they reported no side effects in that year. We could write the code more succinctly like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_sub %>% \n  rowwise() %>% \n  mutate(any_se_year = sum(se_headache, se_diarrhea, se_dry_mouth) > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 6\n# Rowwise: \n      id  year se_headache se_diarrhea se_dry_mouth any_se_year\n   <int> <int>       <int>       <int>        <int> <lgl>      \n 1     1     0           0           1            1 TRUE       \n 2     1     1           1           1            1 TRUE       \n 3     1     2           1           1            0 TRUE       \n 4     2     0           1           1            1 TRUE       \n 5     2     1           0           0            1 TRUE       \n 6     2     2           1           1            1 TRUE       \n 7     3     0           0           0            0 FALSE      \n 8     3     1           0           0            0 FALSE      \n 9     3     2           0           0            0 FALSE      \n10     4     0           0           0            0 FALSE      \n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut, is that really what we want to do? The answer is it depends. If we are going to stop here, then the succinct code may be what we want. But, what if we want to also know if the participant reported _all_ side effects in each year. Perhaps, you've already worked out what that code would look like. Perhaps you're thinking something like:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_sub %>% \n  rowwise() %>% \n  mutate(\n    any_se_year = sum(se_headache, se_diarrhea, se_dry_mouth) > 0,\n    all_se_year = sum(se_headache, se_diarrhea, se_dry_mouth) == 3\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 7\n# Rowwise: \n      id  year se_headache se_diarrhea se_dry_mouth any_se_year all_se_year\n   <int> <int>       <int>       <int>        <int> <lgl>       <lgl>      \n 1     1     0           0           1            1 TRUE        FALSE      \n 2     1     1           1           1            1 TRUE        TRUE       \n 3     1     2           1           1            0 TRUE        FALSE      \n 4     2     0           1           1            1 TRUE        TRUE       \n 5     2     1           0           0            1 TRUE        FALSE      \n 6     2     2           1           1            1 TRUE        TRUE       \n 7     3     0           0           0            0 FALSE       FALSE      \n 8     3     1           0           0            0 FALSE       FALSE      \n 9     3     2           0           0            0 FALSE       FALSE      \n10     4     0           0           0            0 FALSE       FALSE      \n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThat works, and hopefully, you're able to reason out why it works. But, there we go repeating code again! So, in this case, we have to choose between more succinct code and the DRY principle. When presented with that choice, I will typically favor the DRY principle. Therefore, my code would look like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_sub %>% \n  rowwise() %>% \n  mutate(\n    n_se_year   = sum(se_headache, se_diarrhea, se_dry_mouth),\n    any_se_year = n_se_year > 0,\n    all_se_year = n_se_year == 3\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 8\n# Rowwise: \n      id  year se_headache se_diarrhea se_dry_mouth n_se_year any_se_year\n   <int> <int>       <int>       <int>        <int>     <int> <lgl>      \n 1     1     0           0           1            1         2 TRUE       \n 2     1     1           1           1            1         3 TRUE       \n 3     1     2           1           1            0         2 TRUE       \n 4     2     0           1           1            1         3 TRUE       \n 5     2     1           0           0            1         1 TRUE       \n 6     2     2           1           1            1         3 TRUE       \n 7     3     0           0           0            0         0 FALSE      \n 8     3     1           0           0            0         0 FALSE      \n 9     3     2           0           0            0         0 FALSE      \n10     4     0           0           0            0         0 FALSE      \n# ℹ 50 more rows\n# ℹ 1 more variable: all_se_year <lgl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNot only am I less like to make a typing error in this code, but I think the differences between each line of code (i.e., what that line of code is doing) stands out more. In other words, the intent of the code isn't buried in unneeded words.\n\nBefore moving on, I also want to point out that the method above would not have worked on factors. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_sub %>% \n  mutate(\n    se_headache  = factor(se_headache, yn_levs, yn_labs),\n    se_diarrhea  = factor(se_diarrhea, yn_levs, yn_labs),\n    se_dry_mouth = factor(se_dry_mouth, yn_levs, yn_labs)\n  ) %>% \n  rowwise() %>% \n  mutate(\n    n_se_year   = sum(se_headache, se_diarrhea, se_dry_mouth),\n    any_se_year = n_se_year > 0,\n    all_se_year = n_se_year == 3\n  )\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `mutate()`:\nℹ In argument: `n_se_year = sum(se_headache, se_diarrhea,\n  se_dry_mouth)`.\nℹ In row 1.\nCaused by error in `Summary.factor()`:\n! 'sum' not meaningful for factors\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `sum()` function cannot add factors. Back when I [first introduced factors in this book](#factor-vectors), I suggested that you keep the numeric version of your variables in your data frames and create factors as new variables. I said that I thought this was a good idea because I often find that it can be useful to have both versions of the variable hanging around during the analysis process. The situation above is an example of what I was talking about.\n\n### Group_by mutations\n\nSo far, we've created variables that tell us if our participants reported _any_ side effects in a given and if they reported _all 3_ side effects in a given year. The next logical question might be to ask if each participant experienced _any_ side effect in _any year_. For that, we will need `dplyr`'s `group_by()` function. Before discussing `group_by()`, I'm going to show you the code I would use to accomplish this task:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_sub %>% \n  rowwise() %>% \n  mutate(\n    n_se_year   = sum(se_headache, se_diarrhea, se_dry_mouth),\n    any_se_year = n_se_year > 0,\n    all_se_year = n_se_year == 3\n  ) %>% \n  group_by(id) %>% \n  mutate(any_se = sum(any_se_year) > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n# Groups:   id [20]\n      id  year se_headache se_diarrhea se_dry_mouth n_se_year any_se_year\n   <int> <int>       <int>       <int>        <int>     <int> <lgl>      \n 1     1     0           0           1            1         2 TRUE       \n 2     1     1           1           1            1         3 TRUE       \n 3     1     2           1           1            0         2 TRUE       \n 4     2     0           1           1            1         3 TRUE       \n 5     2     1           0           0            1         1 TRUE       \n 6     2     2           1           1            1         3 TRUE       \n 7     3     0           0           0            0         0 FALSE      \n 8     3     1           0           0            0         0 FALSE      \n 9     3     2           0           0            0         0 FALSE      \n10     4     0           0           0            0         0 FALSE      \n# ℹ 50 more rows\n# ℹ 2 more variables: all_se_year <lgl>, any_se <lgl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n👆**Here's what we did above:**\n\n* We created a new column in the `drug_trial_sub` data called `any_se` using the `mutate()` function. The `any_se` column is TRUE if the participant reported _any_ side effect in _any year_ and FALSE if they _never_ reported a side effect in _any year_.\n\n* We first grouped the data by `id` using the `group_by()` function. Note that grouping the data by `id` with `group_by()` overrides grouping the data by row with `rowwise()` as soon as R gets to that point in the code. In other words, the data is grouped by row from `rowwise() %>%` to `group_by(id) %>%` and grouped by `id` after.\n\n<p class=\"note\"> 🗒**Side Note:** You can use `dplyr::ungroup()` to ungroup your data frames. This works regardless of whether you grouped them with `rowwise()` or `group_by()`.</p>\n\nI already introduced `group_by()` in the chapter on [numerical descriptions of categorical variables](#the-tidyverse-way). I also said that `group_by()` operationalizes the **Split - Apply - Combine** strategy for data analysis. That means is that we split our data frame up into smaller data frames, apply our calculation separately to each smaller data frame, and then combine those individual results back together as a single result. \n\nSo, in the example above, the `drug_trial_sub` data frame was split into twenty separate little data frames (i.e., one for each study id). Because there are 3 rows for each study id, each of these 20 little data frames had three rows. \n\nEach of those 20 little data frames was then passed to the `mutate()` function. The name-value pair inside the `mutate()` function `any_se = sum(any_se_year) > 0` told R to add up all the values for the column `any_se_year` (i.e., `sum(any_se_year)`), compare that summed value to `0` (i.e., `sum(any_se_year) > 0`), and then assign `TRUE` to `any_se` if the summed value is greater than zero and `FALSE` otherwise. Then, all 20 of the little data frames are combined back together and returned to us as a single data frame.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrug_trial_sub %>% \n  rowwise() %>% \n  mutate(\n    n_se_year   = sum(se_headache, se_diarrhea, se_dry_mouth),\n    any_se_year = n_se_year > 0,\n    all_se_year = n_se_year == 3\n  ) %>% \n  mutate(any_se = sum(any_se_year) > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 9\n# Rowwise: \n      id  year se_headache se_diarrhea se_dry_mouth n_se_year any_se_year\n   <int> <int>       <int>       <int>        <int>     <int> <lgl>      \n 1     1     0           0           1            1         2 TRUE       \n 2     1     1           1           1            1         3 TRUE       \n 3     1     2           1           1            0         2 TRUE       \n 4     2     0           1           1            1         3 TRUE       \n 5     2     1           0           0            1         1 TRUE       \n 6     2     2           1           1            1         3 TRUE       \n 7     3     0           0           0            0         0 FALSE      \n 8     3     1           0           0            0         0 FALSE      \n 9     3     2           0           0            0         0 FALSE      \n10     4     0           0           0            0         0 FALSE      \n# ℹ 50 more rows\n# ℹ 2 more variables: all_se_year <lgl>, any_se <lgl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nYou may be wondering why I used the `sum()` function when the values for `any_se_year` are not numbers. The way R treats logical vectors can actually be pretty useful in situations like this. That is, when mathematical operations are applied to logical vectors, R treats FALSE as a 0 and TRUE as a 1. So, for participant 1, R calculated the value for `any_se` something like this:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany_se_year <- c(TRUE, TRUE, TRUE)\nany_se_year\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE TRUE TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_any_se_year <- sum(any_se_year)\nsum_any_se_year\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nany_se <- sum_any_se_year > 0\nany_se\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nR used the recycling rules to copy that result to the other two rows of data from participant 1. R then repeated that process for every other participant, and then returned the combined data frame to us.\n\nI hope you found the example above useful. I think it's fairly representative of the kinds of data management stuff I tend to do on a day-to-day basis. Of course, missing data always complicates things (more to come on that!). In the next chapter, we will round out our introduction to the basics of data management by learning how to subset rows and columns of a data frame.",
    "supporting": [
      "creating_and_modifying_columns_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}