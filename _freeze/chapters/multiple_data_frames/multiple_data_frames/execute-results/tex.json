{
  "hash": "7170deef0e52a730475e838b5aea1955",
  "result": {
    "engine": "knitr",
    "markdown": "# Working with Multiple Data Frames\n\n<!--\nStacking data frames vertically\nStacking data frames horizontally\nIntroduction to relational data\nJoining data frames deterministically \nJoining data frames probabilistically \nAdd link to cheat sheet\n-->\n\nUp to this point, the data we‚Äôve needed has always been stored in a single data frame. However, that won‚Äôt always be the case. At times we may need to combine data from multiple agencies in order to complete your analysis. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](agencies.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nAdditionally, large studies often gather data at multiple sites.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](sites.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nOr, data is sometimes gathered over long periods of time. When this happens, it is not uncommon for observations across the study sites or times to be stored as separate data sets.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](time.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nAnother common scenario in which you end up with multiple data sets for the same study is when researchers use different data sets to record the results of different survey instruments or groups of similar instruments.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](instruments.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nIn any of these cases, you may need to combine data from across data sets in order to complete your analysis. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](datasets.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nThis combining of data comes in two basic forms: combining vertically and combining horizontally. First we‚Äôll learn about combining vertically, or adding rows. Later, we‚Äôll learn about combining horizontally, or adding columns.\n\nBelow we have two separate data frames - data frame one and data frame two. In this case both data frames contain the exact same variables: Var1, Var2, and Var3. However, they aren‚Äôt identical because they contain different observations.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](two_data_sets1.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nNow, you want to combine these two data frames and end up with one data frame that includes the observations from data frame two listed directly below the observations from data frame one. This is a situation where we want to combine data frames vertically.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](two_data_sets2.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nWhen combining data frames vertically, one of the most important questions to ask is, ‚Äúdo the data frames have variables in common?‚Äù Just by examining data frame one and data frame two, you can see that the variables have the same names. How can you check to make sure that the variables also contain the same type of data? Well, you can use the `str()` or `glimpse()` functions to compare the details of the columns in the two data frames.\n\nSometimes, you might find that columns that have different names across data frames contain the same data. For example, suppose that data frame one has a variable named ID and data frame two has a variable named subject ID. In this situation you might want R to combine these two variables when you combine data frames.\n\nOn the other hand, you may find that variables that have the same name across data frames, actually contain different data. For example, both data frames may contain the variable `date`. But, one `date` variable might store birth date and the other might store date of admission. You would not want to combine these two variables.\n\nAs you may have guessed, when combining data frames vertically, it‚Äôs easiest to combine data frames that have identical variables. However, you will also learn how to combine data frames that have different variables.\n\n## Combining data frames vertically: Adding rows\n\nSuppose you are working on a multisite clinical trial recruiting participants over multiple years. You have a data frame named Trial, that stores the number of participants recruited each year, as well as the number of participants who experienced the outcome of interest. Another data frame named Trial_2020 was just sent to you with the recruitment numbers for the year 2020. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](trial.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nYou want to add the observations about the participants recruited in 2020 to the master data frame so that it contains the information about all years. To do this, you bind the rows in the `trial_2020` data frame to the `trial` data frame.\n\nLet's go ahead and load `dplyr`:\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nAnd simulate our data frames:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 3\n   year     n outcome\n  <dbl> <dbl>   <dbl>\n1  2016   501      51\n2  2017   499      52\n3  2018   498      49\n4  2019   502      50\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n   year     n outcome\n  <dbl> <dbl>   <dbl>\n1  2020   500      48\n```\n\n\n:::\n:::\n\n\n\n\n\n\nwe can see above that column names and types in both data frames are identical. In this case, we can easily bind them together vertically with `dplyr`'s `bind_rows()` function:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n   year     n outcome\n  <dbl> <dbl>   <dbl>\n1  2016   501      51\n2  2017   499      52\n3  2018   498      49\n4  2019   502      50\n5  2020   500      48\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `bind_rows()` function to vertically stack, or bind, the rows in `trial_2020` to the rows in `trials`.\n\n* You can type `?bind_rows` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n* The first argument to the `bind_rows()` function is the `...` argument. Typically, we will pass one or more data frames that we want to combine to the `...` argument.\n\n### Combining more than 2 data frames\n\nWhat if we want to vertically combine more than two data frames? This isn't a problem. Thankfully, `bind_rows()` lets us pass as many data frames as we want to the `...` argument. For example:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n   year     n outcome\n  <dbl> <dbl>   <dbl>\n1  2021   598      57\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 3\n   year     n outcome\n  <dbl> <dbl>   <dbl>\n1  2016   501      51\n2  2017   499      52\n3  2018   498      49\n4  2019   502      50\n5  2020   500      48\n6  2021   598      57\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Adding rows with differing columns\n\nWhat happens when the data frames we want to combine don't have identical sets of columns? For example, let's say that we started collecting data on adverse events for the first time in 2020. In this case, `trials_2020` would contain a column that `trials` doesn't contain. Can we still row bind our two data frames? Let's see:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 4\n   year     n outcome adv_event\n  <dbl> <dbl>   <dbl>     <dbl>\n1  2020   500      48         3\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 4\n   year     n outcome adv_event\n  <dbl> <dbl>   <dbl>     <dbl>\n1  2016   501      51        NA\n2  2017   499      52        NA\n3  2018   498      49        NA\n4  2019   502      50        NA\n5  2020   500      48         3\n```\n\n\n:::\n:::\n\n\n\n\n\n\nwe sure can! R just sets the value of `adv_event` to `NA` in the rows that came from the `trial` data frame. \n\n### Differing column positions\n\nNext, let's say that the person doing data entry accidently put the columns in a different order in 2020. Is `bind_rows()` able to figure out which columns go together?\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 4\n   year     n adv_event outcome\n  <dbl> <dbl>     <dbl>   <dbl>\n1  2020   500         3      48\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 4\n   year     n outcome adv_event\n  <dbl> <dbl>   <dbl>     <dbl>\n1  2016   501      51        NA\n2  2017   499      52        NA\n3  2018   498      49        NA\n4  2019   502      50        NA\n5  2020   500      48         3\n```\n\n\n:::\n:::\n\n\n\n\n\n\nYes! The `bind_rows()` function binds the data frames together based on column names. So, having our columns in a different order in the two data frames isn't a problem. But, what happens when we have different column names?\n\n### Differing column names\n\nAs a final wrinkle, let's say that the person doing data entry started using different column names in 2020 as well. For example, below, the `n` column is now named `count` and the `outcome` column is now named `outcomes`. Will `bind_rows()` still be able to vertically combine these data frames?\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 4\n   year count adv_event outcomes\n  <dbl> <dbl>     <dbl>    <dbl>\n1  2020   500         3       48\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 6\n   year     n outcome count adv_event outcomes\n  <dbl> <dbl>   <dbl> <dbl>     <dbl>    <dbl>\n1  2016   501      51    NA        NA       NA\n2  2017   499      52    NA        NA       NA\n3  2018   498      49    NA        NA       NA\n4  2019   502      50    NA        NA       NA\n5  2020    NA      NA   500         3       48\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIn this case, `bind_rows()` plays it safe and doesn't make any assumptions about whether columns with different names belong together or not. However, we only need to rename the columns in one data frame or the other to fix this problem. We could do this in separate steps like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 4\n   year     n outcome adv_event\n  <dbl> <dbl>   <dbl>     <dbl>\n1  2016   501      51        NA\n2  2017   499      52        NA\n3  2018   498      49        NA\n4  2019   502      50        NA\n5  2020   500      48         3\n```\n\n\n:::\n:::\n\n\n\n\n\n\nOr, we could rename and bind in a single step by nesting functions like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 4\n   year     n outcome adv_event\n  <dbl> <dbl>   <dbl>     <dbl>\n1  2016   501      51        NA\n2  2017   499      52        NA\n3  2018   498      49        NA\n4  2019   502      50        NA\n5  2020   500      48         3\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we _nested_ the code that we previously used to create the `trial_2020_rename` data frame inside of the `bind_rows()` function instead creating the actual `trial_2020_rename` data frame and passing it to `bind_rows()`.\n\n* I don't think you can really say that one method is \"better\" or \"worse\". The first method requires two steps and creates a data frame in our global environment that we may or may not ever need again (i.e., potentially just clutter). However, one could make an argument that the first method is also easier to glance at and read. I would typically use the second method, but this is really just a personal preference in this case.\n\nAnd that's pretty much it. The `bind_rows()` function makes it really easy to combine R data frames vertically. Next, let's learn how to combine data frames horizontally.\n\n## Combining data frames horizontally: Adding columns\n\nIn this section we will once again begin with two separate data frames - data frame one and data frame two. But, unlike before, these data frames share only one variable in common. And, the data contained in both data frames pertains to the same observations.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](two_data_sets_horiz.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nOur goal is once again to combine these data frames. But, this time we want to combine them horizontally. In other words, we want a combined data frame that combines all the _columns_ from data frame one and data frame two.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](goal.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nCombining data frames horizontally can be slightly more complicated than combining them vertically. As shown in the following flow chart, we can either match the rows of our two data frames up by position or by key values. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](flow_chart.png){width=6in}\n:::\n:::\n\n\n\n\n\n\n### Combining data frames horizontally by position\n\nIn the simplest case, we match the rows in our data frames up by position. In other words, row 1 in data frame one is matched up with row 1 in data frame two, row 2 in data frame one is matched up with row 2 in data frame two, and so on. Row n (meaning, any number) in data frame one always gets matched to row n in data frame two, regardless of the values in any column of those rows.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](position.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nCombining data frames horizontally by position is very easy in R. We just use `dplyr`'s `bind_cols()` function similarly to the way used `bind_rows()` above. Just remember that when we horizontally combine data frames by position both data frames must have the same number of rows. For example:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  color size  \n  <chr> <chr> \n1 red   small \n2 green medium\n3 blue  large \n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  amount  dose\n   <dbl> <dbl>\n1      1    10\n2      4    20\n3      3    30\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 4\n  color size   amount  dose\n  <chr> <chr>   <dbl> <dbl>\n1 red   small       1    10\n2 green medium      4    20\n3 blue  large       3    30\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `bind_cols()` function to horizontally bind the columns in `df1` to the columns in `df2`.\n\n* You can type `?bind_cols` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n* The only argument to the `bind_cols()` function is the `...` argument. Typically, we will pass one or more data frames that we want to combine to the `...` argument.\n\nIn general, it's a bad idea to combine data frames that contain different kinds of information (i.e., variables) about the same set of people (or places or things) in this way. It's difficult to ensure that the information in row n in both data frames is really about the same person (or place or thing). However, we do sometimes find `bind_cols()` to be useful when we're writing our own functions in R. We haven't quite learned how to do that yet, but we will soon. \n\n### Combining data frames horizontally by key values\n\nIn all the examples from here on out we will match the rows of our data frames by one or more key values.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](flow_chart_key_value.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nIn epidemiology, the term I most often hear used for combining data frames in this way is **merging**. So, I will mostly use that term below. However, in other disciplines it is common to use the term **joining**, or performing a data **join**, to mean the same thing. The `dplyr` package, in specific, refers to these as \"mutating joins.\"\n\n#### Relationship types\n\nWhen we merge data frames it‚Äôs important to ask ourselves, ‚Äúwhat is the relationship between the observations in the original data frames?‚Äù The observations can be related in several different ways.\n\nIn a one-to-one relationship, a single observation in one data frame is related to no more than one observation in the other data frame. We know how to align, or connect, the rows in the two data frames based on the values of one or more common variables.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](one_to_one.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nThis common variable, or set of common variables, is also called a **key**. When we use the values in the key to match rows in our data frames, we can say that we are _matching on key values_. \n\nIn the example above, There is one key column -- `Var1`. Both data frames contain the column named `Var1`, and the values of that column tell R how to align the rows in both data frames so that all the values in that row contain data are about the same person, place, or thing. In the example above, we know that the first row of data frame one goes with the _second_ row of data frame two because both rows have the same key value -- `1`.\n\nIn a one-to-many relationship, a single observation in one data frame is related to multiple observations in the other data frame.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](one_to_many.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nAnd finally, in a many-to-many relationship, multiple observations in one data frame are related to multiple observations in the other data frame.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](many_to_many.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nMany-to-many relationships are messy and are generally best avoided, if possible. In practice, we're not sure that we've ever merged two data frames that had a _true_ many-to-many relationship. We emphasize _true_ because we have definitely merged data frames that had a many-to-many relationship when matching on a single key column. However, after matching on multiple key columns (e.g., study id and date instead of just study id), the relationship became one-to-one or one-to-many. We'll see an example of matching on multiple key columns later. \n\n#### dplyr join types\n\nIn this chapter, we will merge data frames using one of `dplyr`'s four mutating join functions. \n\nThe first three arguments to all four of `dplyr`'s mutating join functions are: `x`, `y`, and `by`. You should pass the names of the data frames you want to merge to the `x` and `y` arguments respectively. You should pass the name(s) of the key column(s) to the `by` argument. In many cases, you will get a different merge result depending on which data frame you pass to the `x` and `y` arguments, and which mutating join function you use. Below, we will give you a brief overview of each of the mutating join functions, and then we will jump into some examples.\n\nThe four mutating join functions are:\n\n1. `left_join()`. This is probably the join function that you will use the most. It's important to remember that `left_join()` keeps all the rows from the `x` data frame in the resulting combined data frame. However, it only keeps the rows from the `y` data frame that have a key value match in the `x` data frame. The values for columns with no key value match in the opposite data frame are set to `NA`.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](left_join.png){width=6in}\n:::\n:::\n\n\n\n\n\n\n2. `right_join()`. This is just the mirror opposite of `left_join()`. Accordingly, `right_join()` keeps all the rows from the `y` data frame in the resulting combined data frame, and only keep the rows from the `x` data frame that have a key value match in the `y` data frame. The values for columns with no key value match in the opposite data frame are set to `NA`.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](right_join.png){width=6in}\n:::\n:::\n\n\n\n\n\n\n3. `full_join()`. Full join keeps all the rows from both data frames in the resulting combined data frame. The values for columns with no key value match in the opposite data frame are set to `NA`.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](full_join.png){width=6in}\n:::\n:::\n\n\n\n\n\n\n4. `inner_join()`. Inner join keeps only the rows from both data frames that have a key value match in the opposite data frame in the resulting combined data frame. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](inner_join.png){width=6in}\n:::\n:::\n\n\n\n\n\n\nNow that we have a common vocabulary, let's take a look at some more concrete examples. \n\nSuppose we are analyzing data from a study of aging and functional ability. At baseline, we assigned a study id to each of our participants. We then ask them their date of birth and their race and ethnicity. We saved that information in a data frame called `demographics`. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 3\n  id    dob        race_eth\n  <chr> <date>        <dbl>\n1 1001  1968-12-14        1\n2 1002  1952-08-03        2\n3 1003  1949-05-27        2\n4 1004  1955-03-12        4\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThen, we asked our participants to do a series of functional tests. The functional tests included measuring grip strength in their right hand (`grip_r`) and grip strength in their left hand (`grip_l`). We saved each measure, along with their study id, in a separate data frame called `grip_strength`.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 3\n  id    grip_r grip_l\n  <chr>  <dbl>  <dbl>\n1 1002      32     30\n2 1001      28     30\n3 1003      32     28\n4 1004      22     22\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow, we want to merge these two data frames together so that we can include age, race/ethnicity, and grip strength in our analysis.\n\nLet's first ask ourselves, ‚Äúwhat is the relationship between the observations in `demographics` and the observations in `grip_strength`?‚Äù\n\n#### One-to-one relationship merge\n\nIt's a one-to-one relationship because each participant in `demographics` has no more than one corresponding row in `grip_strength`. Since both data frames have exactly four rows, we can go ahead hand combine them horizontally using `bind_cols()` like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nNew names:\n* `id` -> `id...1`\n* `id` -> `id...4`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 6\n  id...1 dob        race_eth id...4 grip_r grip_l\n  <chr>  <date>        <dbl> <chr>   <dbl>  <dbl>\n1 1001   1968-12-14        1 1002       32     30\n2 1002   1952-08-03        2 1001       28     30\n3 1003   1949-05-27        2 1003       32     28\n4 1004   1955-03-12        4 1004       22     22\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `bind_cols()` function to horizontally bind the columns in `demographics` to the columns in `grip_strength`. **This was a bad idea!** \n\n* Notice the message that `bind_cols()` gave us this time: `New names: * id -> id...1 * id -> id...2`. This is telling us that both data frames had a column named `id`. If `bind_cols()` had left the column names as-is, then the resulting combined data frame would have had two columns named `id`, which isn't allowed.\n\n* **More importantly**, notice the demographic data for participant 1001 is now aligned with the grip strength data for participant 1002, and vice versa. The grip strength data was recorded in the order that participants came in to have their grip strength measured. In this case, participant 1002 came in before 1001. Remember that `bind_cols()` matches rows by position, which results in mismatched data in this case.\n\nNow, let's learn a better way to merge these two data frames -- `dplyr`'s `left_join()` function:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  id    dob        race_eth grip_r grip_l\n  <chr> <date>        <dbl>  <dbl>  <dbl>\n1 1001  1968-12-14        1     28     30\n2 1002  1952-08-03        2     32     30\n3 1003  1949-05-27        2     32     28\n4 1004  1955-03-12        4     22     22\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used `dplyr`'s `left_join()` function to perform a one-to-one merge of the `demographics` data frame with the `grip_strength` data frame.\n\n* You can type `?left_join` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n* The first argument to the `left_join()` function is the `x` argument. You should pass a data frame to the `x` argument.\n\n* The second argument to the `left_join()` function is the `y` argument. You should pass a data frame to the `y` argument.\n\n* The third argument to the `left_join()` function is the `by` argument. You should pass the name of the column, or columns, that contain the key values. The column name should be wrapped in quotes.\n\n* Notice that the demographics and grip strength data are now correctly aligned for participants 1001 and 1002 even though they were still misaligned in the original data frames. That's because row position is irrelevant when we match by key values.\n\n* Notice that the result above only includes a single `id` column. This is because we aren't simply smooshing two data frames together, side-by-side. We are integrating information from across the two data frames based on the value of the key column -- `id`.\n\nThe merge we did above is about as simple as it gets. It was a one-to-one merge where every key value in the `x` data frame had one, and only one, matching key value in the `y` data frame. Therefore, in this simple case, all four join types give us the same result:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  id    dob        race_eth grip_r grip_l\n  <chr> <date>        <dbl>  <dbl>  <dbl>\n1 1001  1968-12-14        1     28     30\n2 1002  1952-08-03        2     32     30\n3 1003  1949-05-27        2     32     28\n4 1004  1955-03-12        4     22     22\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  id    dob        race_eth grip_r grip_l\n  <chr> <date>        <dbl>  <dbl>  <dbl>\n1 1001  1968-12-14        1     28     30\n2 1002  1952-08-03        2     32     30\n3 1003  1949-05-27        2     32     28\n4 1004  1955-03-12        4     22     22\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  id    dob        race_eth grip_r grip_l\n  <chr> <date>        <dbl>  <dbl>  <dbl>\n1 1001  1968-12-14        1     28     30\n2 1002  1952-08-03        2     32     30\n3 1003  1949-05-27        2     32     28\n4 1004  1955-03-12        4     22     22\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAdditionally, aside from the order of the rows and columns in the resulting combined data frame, it makes no difference which data frame you pass to the `x` and `y` arguments in this case:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  id    grip_r grip_l dob        race_eth\n  <chr>  <dbl>  <dbl> <date>        <dbl>\n1 1002      32     30 1952-08-03        2\n2 1001      28     30 1968-12-14        1\n3 1003      32     28 1949-05-27        2\n4 1004      22     22 1955-03-12        4\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAs our merges get more complex, we will get different results depending on which join function we choose and the ordering in which we pass our data frames to the `x` and `y` arguments. We're not going to attempt to cover every possible combination. But, we are going to try to give you a flavor for some of the scenarios we believe you are most likely to encounter in practice.\n\n#### Differing rows\n\nIn the real world, participants don't always attend scheduled visits. Let's suppose that there was actually a fifth participant that we collected baseline data from:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n  id    dob        race_eth\n  <chr> <date>        <dbl>\n1 1001  1968-12-14        1\n2 1002  1952-08-03        2\n3 1003  1949-05-27        2\n4 1004  1955-03-12        4\n5 1005  1942-06-07        3\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHowever, participant 1005 never made it back in for a grip strength test. Now, what do you think will happen when we merge `demographics` and `grip_strength` using `left_join()`?\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 5\n  id    dob        race_eth grip_r grip_l\n  <chr> <date>        <dbl>  <dbl>  <dbl>\n1 1001  1968-12-14        1     28     30\n2 1002  1952-08-03        2     32     30\n3 1003  1949-05-27        2     32     28\n4 1004  1955-03-12        4     22     22\n5 1005  1942-06-07        3     NA     NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe resulting data frame includes _all_ rows from the `demographics` data frame _and all_ the rows from the `grip_strength` data frame. Because participant 1005 never had their grip strength measured, and therefore, had no rows in the `grip_strength` data frame, their values for `grip_r` and `grip_l` are set to missing. \n\nThis scenario is a little a different than the one above. It's still a one-to-one relationship because each participant in `demographics` has no more than one corresponding row in `grip_strength`. However, every key value in the `x` data frame no longer has one, and only one, matching key value in the `y` data frame. Therefore, we will now get different results depending on which join function we choose, and the order in which we pass our data frames to the `x` and `y` arguments. Before reading further, think about what you expect the results from each join function to look like. Think about what you expect the results of switching the data frame order to look like.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  id    dob        race_eth grip_r grip_l\n  <chr> <date>        <dbl>  <dbl>  <dbl>\n1 1001  1968-12-14        1     28     30\n2 1002  1952-08-03        2     32     30\n3 1003  1949-05-27        2     32     28\n4 1004  1955-03-12        4     22     22\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 5\n  id    dob        race_eth grip_r grip_l\n  <chr> <date>        <dbl>  <dbl>  <dbl>\n1 1001  1968-12-14        1     28     30\n2 1002  1952-08-03        2     32     30\n3 1003  1949-05-27        2     32     28\n4 1004  1955-03-12        4     22     22\n5 1005  1942-06-07        3     NA     NA\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  id    dob        race_eth grip_r grip_l\n  <chr> <date>        <dbl>  <dbl>  <dbl>\n1 1001  1968-12-14        1     28     30\n2 1002  1952-08-03        2     32     30\n3 1003  1949-05-27        2     32     28\n4 1004  1955-03-12        4     22     22\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  id    grip_r grip_l dob        race_eth\n  <chr>  <dbl>  <dbl> <date>        <dbl>\n1 1002      32     30 1952-08-03        2\n2 1001      28     30 1968-12-14        1\n3 1003      32     28 1949-05-27        2\n4 1004      22     22 1955-03-12        4\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWell, were those the results you expected? In practice, the \"correct\" result depends on what we are trying to do. In the scenario above, we would probably tend to want the result from `left_join()` or `full_join()` in most cases. The reason is that it's much harder to add data into our analysis that never made it into our combined data frame than it is to drop rows from our results data frame that we don't need for our analysis.\n\n#### Differing key column names\n\nSometimes the key columns will have different names across data frames. For example, let's imagine that the team collecting the grip strength data named the participant id column `pid` instead of `id`:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 3\n  pid   grip_r grip_l\n  <chr>  <dbl>  <dbl>\n1 1002      32     30\n2 1001      28     30\n3 1003      32     28\n4 1004      22     22\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIf we try to merge `demographics` and `grip_strength` as we did before, we will get an error.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n\n```\nError in `left_join()`:\n! Join columns in `y` must be present in the data.\nx Problem with `id`.\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis error is `left_join()` telling us that it couldn't find a column named `id` in both data frames. To get around this error, we can simply tell `left_join()` which column is the matching key column in the opposite data frame using a named vector like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 5\n  id    dob        race_eth grip_r grip_l\n  <chr> <date>        <dbl>  <dbl>  <dbl>\n1 1001  1968-12-14        1     28     30\n2 1002  1952-08-03        2     32     30\n3 1003  1949-05-27        2     32     28\n4 1004  1955-03-12        4     22     22\n5 1005  1942-06-07        3     NA     NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\nJust make sure that the first column name you pass to the named vector (i.e., `\"id\"`) is the name of the key column in the `x` data frame and that the second column name you pass to the named vector (i.e., `\"pid\"`) is the name of the key column in the `y` data frame.\n\n#### One-to-many relationship merge\n\nNow suppose that our grip strength study has a longitudinal design. The demographics data was only collected at enrollment into the study. After all, race and dob don't change. There's no need to ask our participants about them at every follow-up interview. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 3\n  id    dob        race_eth\n  <chr> <date>        <dbl>\n1 1001  1968-12-14        1\n2 1002  1952-08-03        2\n3 1003  1949-05-27        2\n4 1004  1955-03-12        4\n5 1005  1942-06-07        3\n```\n\n\n:::\n:::\n\n\n\n\n\n\nGrip strength, however, was measured pre and post some intervention. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 4\n  id    visit grip_r grip_l\n  <chr> <chr>  <dbl>  <dbl>\n1 1001  pre       32     30\n2 1001  post      33     32\n3 1002  pre       28     30\n4 1002  post      27     30\n5 1003  pre       32     28\n6 1003  post      34     30\n7 1004  pre       22     22\n8 1004  post      27     26\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNow what is the relationship of these two data frames?\n\nThese data frames have a one-to-many relationship because at least one observation in one data frame is related to multiple observations in the other data frame. The `demographics` data frame has one observation for each value of `id`. The `grip_strength` data frame has two observations for each value of the `id`'s `1001` through `1004`.\n\nNow, to conduct our analysis, we need to combine the data in `demographics` with the data in the longitudinal `grip_strength` data frame. And how will we ask R to merge these two data frames? Well, here is some good news. To perform a one-to-many or many-to",
    "supporting": [
      "multiple_data_frames_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}