{
  "hash": "c099902a6f7f3329b9d9febcf202427f",
  "result": {
    "engine": "knitr",
    "markdown": "# Subsetting Data Frames\n\n<!--\nselect\n  - tidy-select\n  - Subsetting by name and position\nrename\nfilter\n  - missing data\n  - Delete all missing\narrange\ndeduplication\n  - numbering rows\n  - No difference - drop\n  - Obviously an error - drop\n  - Systematically do something and report it\n  - Don't pick and choose, or even give the appearance of picking and choosing, rows with values that are aligned with the results you want to see.\n\nMaybe modulo operator\nMaybe logical indexes\n-->\n\nSubsetting data frames is another one of the most common data management tasks we carryout in our data analysis projects. Subsetting data frames just refers to the process of deciding which columns and rows to keep in your data frame and which to drop.\n\nFor example, we may need to subset the rows of a data frame because we're interested in understanding a subpopulation in our sample. Below, we only want to analyze the rows that correspond to participants from Texas.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](rows.png){width=900}\n:::\n:::\n\n\n\n\n\n\nOr, perhaps we're only interested in a subset of the statistics returned to me in a data frame of analysis results. Below, we only want to view and present the variable name, variable category, count, and percent.\n \n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](columns.png){width=900}\n:::\n:::\n\n\n\n\n\n\nFortunately, the `dplyr` package includes functions that make it really easy for us to subset our data frames -- even in some fairly complicated ways. Let's start by simulating the same drug trial data we simulated in the last chapter and use it to work through some examples.\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\nAs a reminder, we are simulating some drug trial data that includes the following variables:\n\n* id: Study id, there are 20 people enrolled in the trial.\n  \n* year: Follow-up year, 0 = baseline, 1 = year one, 2 = year two.\n  \n* age: Participant age a baseline. Must be between the ages of 35 and 75 at baseline to be eligible for the study.\n  \n* drug: Drug the participant received, Placebo or active.\n  \n* se_headache: Reported headaches side effect, Y/N.\n  \n* se_diarrhea: Report diarrhea side effect, Y/N.\n  \n* se_dry_mouth: Report dry mouth side effect, Y/N.\n  \n* mi: Participant had myocardial infarction in study year, Y/N. \n\nActually, this data is slightly different than the data we used in the last chapter. Did you catch the difference? Take another look:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 7\n    year   age drug    se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <chr>         <int>       <int>        <int> <int>\n 1     0    65 Active            0           1            1     0\n 2     1    65 Active            1           1            1     0\n 3     2    65 Active            1           1            0     0\n 4     0    49 Active            1           1            1     0\n 5     1    49 Active            0           0            1     0\n 6     2    49 Active            1           1            1     0\n 7     0    48 Placebo           0           0            0     0\n 8     1    48 Placebo           0           0            0     0\n 9     2    48 Placebo           0           0            0     0\n10     0    37 Placebo           0           0            0     0\n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nwe forgot to put a study id in our data. Because we simulated this data above, the best way to fix this oversite is to make the necessary change to the simulation code above. But, let's pretend that someone sent us this data instead, and we have to add a new study id column to it. Well, we now know how to use the `mutate()` function to columns to our data frame. We can do so like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 8\n    year   age drug    se_headache se_diarrhea se_dry_mouth    mi    id\n   <int> <int> <chr>         <int>       <int>        <int> <int> <int>\n 1     0    65 Active            0           1            1     0     1\n 2     1    65 Active            1           1            1     0     1\n 3     2    65 Active            1           1            0     0     1\n 4     0    49 Active            1           1            1     0     2\n 5     1    49 Active            0           0            1     0     2\n 6     2    49 Active            1           1            1     0     2\n 7     0    48 Placebo           0           0            0     0     3\n 8     1    48 Placebo           0           0            0     0     3\n 9     2    48 Placebo           0           0            0     0     3\n10     0    37 Placebo           0           0            0     0     4\n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAnd now we have the study id in our data. But, by default R adds new columns as the rightmost column of the data frame. In terms of analysis, it doesn't really matter where this column is located in our data. R couldn't care less. However, when humans look at this data, they typically expect the study id (or some other identifier) to be the first column in the data frame. That is a job for `select()`.\n\n## The select() function\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 7\n      id  year   age se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <int>       <int>       <int>        <int> <int>\n 1     1     0    65           0           1            1     0\n 2     1     1    65           1           1            1     0\n 3     1     2    65           1           1            0     0\n 4     2     0    49           1           1            1     0\n 5     2     1    49           0           0            1     0\n 6     2     2    49           1           1            1     0\n 7     3     0    48           0           0            0     0\n 8     3     1    48           0           0            0     0\n 9     3     2    48           0           0            0     0\n10     4     0    37           0           0            0     0\n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `select()` function to change the order of the columns in the `drug_trial` data frame so that `id` would be the first variable in the data frame when reading from left to right.\n\n* You can type `?select` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n* The first argument to the `select()` function is `.data`. The value passed to `.data` should always be a data frame. In this book, we will often pass data frames to the `.data` argument using the pipe operator (e.g., `df %>% select()`). \n\n* The second argument to the `select()` function is `...`. The value passed to the `...` argument should column names or expressions that return column positions. We'll dive deeper into this soon.\n\nMore generally, the `select()` function tells R which variables in your data frame to keep (or drop) and in what order.\n\nThe code above gave us the result we wanted. üëè But, it can be tedious and error prone to manually type every variable name inside the `select()` function. Did you notice that we forgot the `drug` column \"by accident\"? \n\nThankfully, the `select()` function is one of several `dplyr` functions that accept [tidy-select](https://dplyr.tidyverse.org/reference/dplyr_tidy_select.html) argument modifiers (i.e., functions and operators). In this chapter, we will show you some of the tidy-select argument modifiers we regularly use, but you can always type `?dplyr_tidy_select` into your console to see a complete list.\n\nIn our little example above, we could have used the tidy-select `everything()` function to make our code easier to write and we wouldn't have accidently missed the `drug` column. We can do so like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 8\n      id  year   age drug    se_headache se_diarrhea se_dry_mouth    mi\n   <int> <int> <int> <chr>         <int>       <int>        <int> <int>\n 1     1     0    65 Active            0           1            1     0\n 2     1     1    65 Active            1           1            1     0\n 3     1     2    65 Active            1           1            0     0\n 4     2     0    49 Active            1           1            1     0\n 5     2     1    49 Active            0           0            1     0\n 6     2     2    49 Active            1           1            1     0\n 7     3     0    48 Placebo           0           0            0     0\n 8     3     1    48 Placebo           0           0            0     0\n 9     3     2    48 Placebo           0           0            0     0\n10     4     0    37 Placebo           0           0            0     0\n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `select()` function to change the order of the columns in the `drug_trial` data frame so that `id` would be the first variable in the data frame when reading from left to right. \n\n* Rather than explicitly typing the other column names, we used the `everything()` tidy-select function. As you may have guessed, `everything()` tells R to do X (in this keep) to all the other variables not explicitly mentioned.\n\nFor our next example, let's go ahead and add our mean-centered age variable to our `drug_trial` data again. We did this for the first time in the last chapter, in case you missed.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 9\n      id  year   age drug  se_headache se_diarrhea se_dry_mouth    mi age_center\n   <int> <int> <int> <chr>       <int>       <int>        <int> <int>      <dbl>\n 1     1     0    65 Acti‚Ä¶           0           1            1     0       11.3\n 2     1     1    65 Acti‚Ä¶           1           1            1     0       11.3\n 3     1     2    65 Acti‚Ä¶           1           1            0     0       11.3\n 4     2     0    49 Acti‚Ä¶           1           1            1     0       -4.7\n 5     2     1    49 Acti‚Ä¶           0           0            1     0       -4.7\n 6     2     2    49 Acti‚Ä¶           1           1            1     0       -4.7\n 7     3     0    48 Plac‚Ä¶           0           0            0     0       -5.7\n 8     3     1    48 Plac‚Ä¶           0           0            0     0       -5.7\n 9     3     2    48 Plac‚Ä¶           0           0            0     0       -5.7\n10     4     0    37 Plac‚Ä¶           0           0            0     0      -16.7\n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nOne way  we will often use `select()` is for performing quick little **data checks**. For example, let's say that we wanted to make sure the code we wrote above actually _did_ what we _intended_ it to do. If we print the entire data frame to the screen, `age` and `age_center` aren't directly side-by-side, and there's a lot of other visual clutter from the other variables. In a case like this, we would use `select()` to get a clearer picture:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 2\n     age age_center\n   <int>      <dbl>\n 1    65       11.3\n 2    65       11.3\n 3    65       11.3\n 4    49       -4.7\n 5    49       -4.7\n 6    49       -4.7\n 7    48       -5.7\n 8    48       -5.7\n 9    48       -5.7\n10    37      -16.7\n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `select()` function to view the `age` and `age_center` columns _only_.\n\n* we can type individual column names, separated by commas, into `select()` to return a data frame containing only those columns, and in that order.\n\n<p class=\"warning\"> ‚ö†Ô∏è**Warning:** Notice that we didn't assign our result above to anything (i.e., there's no `drug_trial <-`). If we had done so, the `drug_trial` data would have contained these two columns only. We didn't want to drop the other columns. We could have assigned the result of the code to a different R object (e.g., `check_age <-`, but it wasn't really necessary. We just wanted to quickly view `age` and `age_center` side-by-side for data checking purposes. When we're satisfied that we coded it correctly, we can move on. There's no need to save those results to an R object.</p>\n\nYou may also recall that we wanted to subset the `drug_trial` data to include only the columns we needed for the rowwise demonstrations. Here is the code we used to do so:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 5\n      id  year se_headache se_diarrhea se_dry_mouth\n   <int> <int>       <int>       <int>        <int>\n 1     1     0           0           1            1\n 2     1     1           1           1            1\n 3     1     2           1           1            0\n 4     2     0           1           1            1\n 5     2     1           0           0            1\n 6     2     2           1           1            1\n 7     3     0           0           0            0\n 8     3     1           0           0            0\n 9     3     2           0           0            0\n10     4     0           0           0            0\n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `select()` function to view the `id` `year`, `se_headache`, `se_diarrhea`, and `se_dry_mouth` columns _only_.\n\n* we used the tidy-select `starts_with()` function to select all the side effect variables.\n\nwe already know that we can use `everything()` to select _all_ of the other variables in a data frame, but what if we just want to grab a _range_ or _group_ of other variables in a data frame? tidy-select makes it easy for us. Above, we used the `starts_with()` function to select all the columns with names that literally start with the letters \"se\". Because all of the side effect columns are directly next to each other (i.e., no columns in between them) we could have also used the colon operator `:` like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 5\n      id  year se_headache se_diarrhea se_dry_mouth\n   <int> <int>       <int>       <int>        <int>\n 1     1     0           0           1            1\n 2     1     1           1           1            1\n 3     1     2           1           1            0\n 4     2     0           1           1            1\n 5     2     1           0           0            1\n 6     2     2           1           1            1\n 7     3     0           0           0            0\n 8     3     1           0           0            0\n 9     3     2           0           0            0\n10     4     0           0           0            0\n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWhile either method gets us the same result, we tend to prefer using `starts_with()` when possible. We think it makes your code easier to read (i.e., \"Oh, he's selecting all the side effect columns here.\").\n\nIn addition to `starts_with()`, there is also an `ends_with()` tidy-select function that can also be useful. For example, we've named factors with the `_f` naming convention throughout the book. We could use that, along with the `ends-with()` function to create a subset of our data that includes only the factor versions of our side effects columns.\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 5\n      id  year se_headache_f se_diarrhea_f se_dry_mouth_f\n   <int> <int> <fct>         <fct>         <fct>         \n 1     1     0 No            Yes           Yes           \n 2     1     1 Yes           Yes           Yes           \n 3     1     2 Yes           Yes           No            \n 4     2     0 Yes           Yes           Yes           \n 5     2     1 No            No            Yes           \n 6     2     2 Yes           Yes           Yes           \n 7     3     0 No            No            No            \n 8     3     1 No            No            No            \n 9     3     2 No            No            No            \n10     4     0 No            No            No            \n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\nüóí**Side Note:** Variable names are important! Throughout this book, I've tried to repeatedly emphasize the importance of coding style -- including the way we name our R objects. Many people who are new to data management and analysis (and some who aren't, **MDL**) don't fully appreciate the importance of such things. We hope that the preceding two examples are helping you to see why the little details, like variable names, are important. Using consistent variable naming conventions, for example, allows us to write code that requires less typing, is easier for humans to skim and understand, and is less prone to typos and other related errors.\n:::\n\nwe can also select columns we want to keep by position instead of name. We don't do this often. We think it's generally better to use column names or tidy-select argument modifiers when subsetting columns in your data frame. However, we do sometimes select columns by position when we're writing our own functions. Therefore, we want to quickly show you what this looks like:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 3\n      id  year drug   \n   <int> <int> <chr>  \n 1     1     0 Active \n 2     1     1 Active \n 3     1     2 Active \n 4     2     0 Active \n 5     2     1 Active \n 6     2     2 Active \n 7     3     0 Placebo\n 8     3     1 Placebo\n 9     3     2 Placebo\n10     4     0 Placebo\n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we passed column numbers to the `select()` function to keep the 1st, 2nd, and 4th columns from our `drug_trial` data frame.\n\nFinally, in addition to using `select()` to _keep_ columns in our data frame, we can also use `select()` to explicitly _drop_ columns from our data frame. To do so, we just need to use either the subtraction symbol (`-`) or the Not operator (`!`).\n\nThink back to our example from the previous chapter. There we created some new variables that captured information about participants reporting _any_ and _all_ side effects. During that process we created a column that contained a count of the side effects experienced in each year -- `n_se_year`.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 6\n      id  year n_se_year any_se_year all_se_year any_se\n   <int> <int>     <int> <lgl>       <lgl>       <lgl> \n 1     1     0         2 TRUE        FALSE       TRUE  \n 2     1     1         3 TRUE        TRUE        TRUE  \n 3     1     2         2 TRUE        FALSE       TRUE  \n 4     2     0         3 TRUE        TRUE        TRUE  \n 5     2     1         1 TRUE        FALSE       TRUE  \n 6     2     2         3 TRUE        TRUE        TRUE  \n 7     3     0         0 FALSE       FALSE       FALSE \n 8     3     1         0 FALSE       FALSE       FALSE \n 9     3     2         0 FALSE       FALSE       FALSE \n10     4     0         0 FALSE       FALSE       FALSE \n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLet's say we decided we don't need `n_se_year` column now that we created `any_se_year`, `all_se_year`, and `any_se`. We can easily drop it from the data frame in a couple of ways:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 5\n      id  year any_se_year all_se_year any_se\n   <int> <int> <lgl>       <lgl>       <lgl> \n 1     1     0 TRUE        FALSE       TRUE  \n 2     1     1 TRUE        TRUE        TRUE  \n 3     1     2 TRUE        FALSE       TRUE  \n 4     2     0 TRUE        TRUE        TRUE  \n 5     2     1 TRUE        FALSE       TRUE  \n 6     2     2 TRUE        TRUE        TRUE  \n 7     3     0 FALSE       FALSE       FALSE \n 8     3     1 FALSE       FALSE       FALSE \n 9     3     2 FALSE       FALSE       FALSE \n10     4     0 FALSE       FALSE       FALSE \n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 5\n      id  year any_se_year all_se_year any_se\n   <int> <int> <lgl>       <lgl>       <lgl> \n 1     1     0 TRUE        FALSE       TRUE  \n 2     1     1 TRUE        TRUE        TRUE  \n 3     1     2 TRUE        FALSE       TRUE  \n 4     2     0 TRUE        TRUE        TRUE  \n 5     2     1 TRUE        FALSE       TRUE  \n 6     2     2 TRUE        TRUE        TRUE  \n 7     3     0 FALSE       FALSE       FALSE \n 8     3     1 FALSE       FALSE       FALSE \n 9     3     2 FALSE       FALSE       FALSE \n10     4     0 FALSE       FALSE       FALSE \n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNote that we could have also dropped it indirectly by selecting everything else:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 5\n      id  year any_se_year all_se_year any_se\n   <int> <int> <lgl>       <lgl>       <lgl> \n 1     1     0 TRUE        FALSE       TRUE  \n 2     1     1 TRUE        TRUE        TRUE  \n 3     1     2 TRUE        FALSE       TRUE  \n 4     2     0 TRUE        TRUE        TRUE  \n 5     2     1 TRUE        FALSE       TRUE  \n 6     2     2 TRUE        TRUE        TRUE  \n 7     3     0 FALSE       FALSE       FALSE \n 8     3     1 FALSE       FALSE       FALSE \n 9     3     2 FALSE       FALSE       FALSE \n10     4     0 FALSE       FALSE       FALSE \n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut, we think this is generally a bad idea. Not only is it more typing, but skimming through your code doesn't really tell us (or future you) what you were trying to accomplish there.\n\n## The rename() function\n\nSometimes, we want to change the names of some, or all, of the columns in our data frame. For me, this most commonly comes up with data I've imported from someone else. For example, let's say I'm importing data that uses column names that aren't super informative. We saw column names like that when we imported NHANES data. It looked something like this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 3\n   SEQN ALQ101 ALQ110\n  <int>  <dbl>  <dbl>\n1     1      1      2\n2     2      2      2\n3     3      1      2\n4     4      2      1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nwe previously learned how to change these column names on import (i.e., `col_names`), but let's say we didn't do that for whatever reason. We can rename columns in our data frame using the `rename()` function like so:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 3\n     id drinks_12_year drinks_12_life\n  <int>          <dbl>          <dbl>\n1     1              1              2\n2     2              2              2\n3     3              1              2\n4     4              2              1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `rename()` function to change the name of each column in the `drug_trial` data frame to be more informative.\n\n* You can type `?rename` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n* The first argument to the `rename()` function is `.data`. The value passed to `.data` should always be a data frame. In this book, we will often pass data frames to the `.data` argument using the pipe operator (e.g., `df %>% rename()`). \n\n* The second argument to the `rename()` function is `...`. The value passed to the `...` argument should be a name value pair, or series of name-value pairs separated by columns. The name-value pairs should be in the format `new name = original name`. \n\nwe think these names are much better, but for the sake of argument let's say that we wanted to keep the original names -- just coerce them to lowercase. We can do that using the `rename_with()` variation of the `rename()` function in combination with the `tolower()` function:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 3\n   seqn alq101 alq110\n  <int>  <dbl>  <dbl>\n1     1      1      2\n2     2      2      2\n3     3      1      2\n4     4      2      1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `rename_with()` function to coerce all column names in the `drug_trial` data frame to lowercase.\n\n* You can type `?rename` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n* The first argument to the `rename_with()` function is `.data`. The value passed to `.data` should always be a data frame. In this book, we will often pass data frames to the `.data` argument using the pipe operator (e.g., `df %>% rename_with()`). \n\n* The second argument to the `rename_with()` function is `.fn`. The value passed to the `.fn` argument should be a function that you want to apply to all the columns selected in the `.cols` argument (see below).\n\n* The third argument to the `rename_with()` function is `.cols`. The value passed to the `.cols` argument should be the columns you want to apply the function passed to the `.fn` argument to. You can select the columns using tidy-select argument modifiers.\n\n## The filter() function\n\nwe just saw how to keep and drop _columns_ in our data frame using the `select()` function. We can keep and drop _rows_ in our data frame using the _filter()_ function or the _slice()_ function. \n\nSimilar to selecting columns by position instead of name:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 √ó 3\n      id  year drug   \n   <int> <int> <chr>  \n 1     1     0 Active \n 2     1     1 Active \n 3     1     2 Active \n 4     2     0 Active \n 5     2     1 Active \n 6     2     2 Active \n 7     3     0 Placebo\n 8     3     1 Placebo\n 9     3     2 Placebo\n10     4     0 Placebo\n# ‚Ñπ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nwe can also select rows we want to keep by position. Again, we don't do this often, but it is sometimes useful when we're writing our own functions. Therefore, we want to quickly show you what this looks like:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 √ó 12\n     id  year   age drug   se_headache se_diarrhea se_dry_mouth    mi age_center\n  <int> <int> <int> <chr>        <int>       <int>        <int> <int>      <dbl>\n1     1     0    65 Active           0           1            1     0       11.3\n2     1     1    65 Active           1           1            1     0       11.3\n3     1     2    65 Active           1           1            0     0       11.3\n4     2     0    49 Active           1           1            1     0       -4.7\n5     2     1    49 Active           0           0            1     0       -4.7\n# ‚Ñπ 3 more variables: se_headache_f <fct>, se_diarrhea_f <fct>,\n#   se_dry_mouth_f <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `slice()` function to keep only the first 5 rows in the `drug_trial` data frame.\n\n* You can type `?slice` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n* The first argument to the `slice()` function is `.data`. The value passed to `.data` should always be a data frame. In this book, we will often pass data frames to the `.data` argument using the pipe operator (e.g., `df %>% slice()`). \n\n* The second argument to the `slice()` function is `...`. The value passed to the `...` argument should be a row numbers you want returned to you. \n\nGenerally speaking, we're far more likely to use the `filter()` function to select only a subset of rows from our data frame. Two of the most common scenarios, of many possible scenarios, where want to subset rows include:\n\n* Performing a subgroup analysis. This is a situation where we want our analysis to include only some of the people (or places, or things) in our data frame.\n\n* Performing a complete case analysis. This is a situation where we want to remove rows that contain missing values from our data frame before performing an analysis.\n\n### Subgroup analysis\n\nLet's say that we want to count the number of people in the drug trial who reported having headaches in the baseline year by drug status (active vs. placebo). We would first use `filter()` to keep only the rows that contain data from the baseline year:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 √ó 12\n      id  year   age drug  se_headache se_diarrhea se_dry_mouth    mi age_center\n   <int> <int> <int> <chr>       <int>       <int>        <int> <int>      <dbl>\n 1     1     0    65 Acti‚Ä¶           0           1            1     0     11.3  \n 2     2     0    49 Acti‚Ä¶           1           1            1     0     -4.7  \n 3     3     0    48 Plac‚Ä¶           0           0            0     0     -5.7  \n 4     4     0    37 Plac‚Ä¶           0           0            0     0    -16.7  \n 5     5     0    71 Plac‚Ä¶           0           0            0     0     17.3  \n 6     6     0    48 Plac‚Ä¶           0           0            0     0     -5.7  \n 7     7     0    59 Acti‚Ä¶           1           1            1     0      5.3  \n 8     8     0    60 Plac‚Ä¶           0           0            0     0      6.3  \n 9     9     0    61 Acti‚Ä¶           1           1            1     0      7.3  \n10    10     0    39 Acti‚Ä¶           1           0            1     0    -14.7  \n11    11     0    61 Plac‚Ä¶           0           0            0     0      7.3  \n12    12     0    62 Plac‚Ä¶           1           0            1     0      8.3  \n13    13     0    43 Plac‚Ä¶           0           0            0     0    -10.7  \n14    14     0    63 Plac‚Ä¶           0           0            0     0      9.3  \n15    15     0    69 Acti‚Ä¶           1           1            1     0     15.3  \n16    16     0    42 Plac‚Ä¶           0           0            0     0    -11.7  \n17    17     0    60 Plac‚Ä¶           0           0            0     0      6.3  \n18    18     0    41 Acti‚Ä¶           1           1            1     0    -12.7  \n19    19     0    43 Plac‚Ä¶           0           0            0     0    -10.7  \n20    20     0    53 Plac‚Ä¶           0           0            0     0     -0.700\n# ‚Ñπ 3 more variables: se_headache_f <fct>, se_diarrhea_f <fct>,\n#   se_dry_mouth_f <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `filter()` function to keep only the rows in the `drug_trial` data frame that contain data from the baseline year.\n\n* You can type `?filter` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n* The first argument to the `filter()` function is `.data`. The value passed to `.data` should always be a data frame. In this book, we will often pass data frames to the `.data` argument using the pipe operator (e.g., `df %>% filter()`). \n\n* The second argument to the `filter()` function is `...`. The value passed to the `...` argument should be a name-value pair or multiple name value pairs separated by commas. The `...` argument is where you will tell `filter()` how to decide which rows to keep.\n\n::: {.callout-warning}\n‚ö†Ô∏è**Warning:** Remember, that in the R language `=` (i.e., one equal sign) and `==` (i.e., two equal signs) are different things. The `=` operator _tells_ R to _make_ the thing on the left equal to the thing on the right. In other words, it _assigns_ values. The `==` _asks_ R if the thing on the left is equal to the thing on the right. In other words, it _test the equality_ of values.\n:::\n\nNow, we can use the descriptive analysis techniques we've already learned to answer our research question:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 3\n# Groups:   drug [2]\n  drug    se_headache_f     n\n  <chr>   <fct>         <int>\n1 Active  No                1\n2 Active  Yes               6\n3 Placebo No               12\n4 Placebo Yes               1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nSo, 6 out of 7 (~ 86%) of the people in our active drug group reported headaches in the baseline year. Now, let's say that we have reason to suspect that the drug affects people differently based on their age. Let's go ahead and repeat this analysis, but only in a subgroup of people who are below age 65. Again, we can use the `filter()` function to do this:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 3\n# Groups:   drug [2]\n  drug    se_headache_f     n\n  <chr>   <fct>         <int>\n1 Active  Yes               5\n2 Placebo No               11\n3 Placebo Yes               1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWow! It looks like everyone under age 65 who received active drug also reported headaches!\n\nwe can show this more explicitly by using passing the value `FALSE` to the `.drop` argument of `group_by()`. This tells R to keep all factor levels in the output, even if they were _observed_ in the data zero times.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 3\n# Groups:   drug [2]\n  drug    se_headache_f     n\n  <chr>   <fct>         <int>\n1 Active  No                0\n2 Active  Yes               5\n3 Placebo No               11\n4 Placebo Yes               1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nFinally, we could make our code above more succinct by combining our two filter functions into one:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 3\n# Groups:   drug [2]\n  drug    se_headache_f     n\n  <chr>   <fct>         <int>\n1 Active  No                0\n2 Active  Yes               5\n3 Placebo No               11\n4 Placebo Yes               1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `filter()` function to keep only the rows in the `drug_trial` data frame that contain data from the baseline year _AND_ (`&`) contain data from rows with a value that is less than 65 in the `age` column. The _AND_ (`&`) here is important. A row must satisfy both of these conditions in order for R to keep it in the returned data frame. If we had used _OR_ instead (`filter(year == 0 | age < 65)`), then only one condition _OR_ the other would need to be met for R to keep the row in the returned data frame.\n\n::: {.callout-note}\nüóí**Side Note:** In the R language, we use the pipe operator to create _OR_ conditions. The pipe operator looks like `|` and is probably the key immediately to the right of your enter/return key on your keyboard.\n:::\n\n### Complete case analysis\n\nNow let's say that we want to compare age at baseline by drug status (active vs. placebo). Additionally, let's say that we have some missing values in our data. \n\nLet's first simulate some new data with missing values:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 √ó 12\n      id  year   age drug  se_headache se_diarrhea se_dry_mouth    mi age_center\n   <int> <int> <int> <chr>       <int>       <int>        <int> <int>      <dbl>\n 1     1     0    NA Acti‚Ä¶           0           1            1     0       11.3\n 2     2     0    49 Acti‚Ä¶           1           1            1     0       -4.7\n 3     3     0    48 Plac‚Ä¶           0           0            0     0       -5.7\n 4     4     0    37 <NA>            0           0            0     0      -16.7\n 5     5     0    71 Plac‚Ä¶           0           0            0     0       17.3\n 6     6     0    48 Plac‚Ä¶           0           0            0     0       -5.7\n 7     7     0    59 Acti‚Ä¶           1           1            1     0        5.3\n 8     8     0    60 Plac‚Ä¶           0           0            0     0        6.3\n 9     9     0    61 Acti‚Ä¶           1           1            1     0        7.3\n10    10     0    39 Acti‚Ä¶           1           0            1     0      -14.7\n# ‚Ñπ 3 more variables: se_headache_f <fct>, se_diarrhea_f <fct>,\n#   se_dry_mouth_f <fct>\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `filter()` and `slice()` functions to create a new data frame that contains only a subset of our original `drug_trial` data frame. The subset includes only the first 10 rows of the data frame remaining after selecting only the baseline year rows from the original data frame.\n\n* we used the `replace()` function to replace the first value of age with `NA` and the fourth value of `drug` with `NA`.\n\n* You can type `?replace` into your R console to view the help documentation for this function.\n\nIf we try to answer our research question above without dealing with the missing data, we get the following undesirable results:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 2\n  drug    mean_age\n  <chr>      <dbl>\n1 Active      NA  \n2 Placebo     56.8\n3 <NA>        37  \n```\n\n\n:::\n:::\n\n\n\n\n\n\nOne way we can improve our result is by adding the `na.rm` argument to the `mean()` function. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 2\n  drug    mean_age\n  <chr>      <dbl>\n1 Active      52  \n2 Placebo     56.8\n3 <NA>        37  \n```\n\n\n:::\n:::\n\n\n\n\n\n\nBut, we previously saw how it can sometimes be more efficient to drop the row with missing data from the data frame explicitly. This is called a **complete case analysis** or **list-wise deletion**. \n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 2\n  drug    mean_age\n  <chr>      <dbl>\n1 Active      52  \n2 Placebo     56.8\n3 <NA>        37  \n```\n\n\n:::\n:::\n\n\n\n\n\n\nHowever, we still have that missing value for `drug`. We can easily drop the row with the missing value by adding an additional value to the `...` argument of our `filter()` function:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 √ó 2\n  drug    mean_age\n  <chr>      <dbl>\n1 Active      52  \n2 Placebo     56.8\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Deduplication\n\nAnother common data management task that we want to discuss in this chapter is deduplicating data. Let's go ahead and simulate some data to illustrate what we mean:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 √ó 3\n      id   day     x\n   <dbl> <dbl> <dbl>\n 1     1     1     1\n 2     1     2    11\n 3     2     1    12\n 4     2     2    13\n 5     2     2    14\n 6     3     1    12\n 7     3     1    12\n 8     3     2    13\n 9     4     1    13\n10     5     1    10\n11     5     2    11\n12     5     1    10\n```\n\n\n:::\n:::\n\n\n\n\n\n\n* All id's but 4 have multiple observations.\n\n* ID 2 has row with duplicate values for `id` and `day`, but a non-duplicate value for `x`. These rows are partial duplicates. \n\n* ID 3 has a row with duplicate values for all three columns (i.e., `3, 1, 12`). These rows are complete duplicates.\n\n* ID 5 has a row with duplicate values for all three columns (i.e., `5, 1, 10`). These rows are complete duplicates. However, they are not in sequential order in the dataset.\n\n### The distinct() function\n\nwe can use `dplyr`'s `distinct()` function to remove all complete duplicates from the data frame:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 √ó 3\n      id   day     x\n   <dbl> <dbl> <dbl>\n 1     1     1     1\n 2     1     2    11\n 3     2     1    12\n 4     2     2    13\n 5     2     2    14\n 6     3     1    12\n 7     3     2    13\n 8     4     1    13\n 9     5     1    10\n10     5     2    11\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `distinct()` function to keep only one row from a group of complete duplicate rows in the `df` data frame.\n\n* You can type `?distinct` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n* The first argument to the `distinct()` function is `.data`. The value passed to `.data` should always be a data frame. In this book, we will often pass data frames to the `.data` argument using the pipe operator (e.g., `df %>% distinct()`). \n\n* The second argument to the `distinct()` function is `...`. The value passed to the `...` argument should be the variables to use when determining uniqueness. Passing no variables to the `...` argument is equivalent to pass all variables to the `...` argument.\n\n### Complete duplicate row add tag\n\nIf want to identify the complete duplicate rows, without immediately dropping them, we can use the `duplicated()` function inside the `mutate()` function. This creates a new column in our data frame that has the value `TRUE` when the row is a complete duplicate and the value `FALSE` otherwise.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 √ó 4\n      id   day     x dup  \n   <dbl> <dbl> <dbl> <lgl>\n 1     1     1     1 FALSE\n 2     1     2    11 FALSE\n 3     2     1    12 FALSE\n 4     2     2    13 FALSE\n 5     2     2    14 FALSE\n 6     3     1    12 FALSE\n 7     3     1    12 TRUE \n 8     3     2    13 FALSE\n 9     4     1    13 FALSE\n10     5     1    10 FALSE\n11     5     2    11 FALSE\n12     5     1    10 TRUE \n```\n\n\n:::\n:::\n\n\n\n\n\n\nAlternatively, we could get the same result using:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 √ó 5\n# Groups:   id, day, x [10]\n      id   day     x n_row dup  \n   <dbl> <dbl> <dbl> <int> <lgl>\n 1     1     1     1     1 FALSE\n 2     1     2    11     1 FALSE\n 3     2     1    12     1 FALSE\n 4     2     2    13     1 FALSE\n 5     2     2    14     1 FALSE\n 6     3     1    12     1 FALSE\n 7     3     1    12     2 TRUE \n 8     3     2    13     1 FALSE\n 9     4     1    13     1 FALSE\n10     5     1    10     1 FALSE\n11     5     2    11     1 FALSE\n12     5     1    10     2 TRUE \n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `group_by_all()` function to split our data frame into multiple data frames grouped by all the columns in `df`. \n\n* we used the `row_number()` to sequentially count every row in each of the little data frames created by `group_by_all()`. We assigned the sequential count to a new column named `n_row`.\n\n* we created a new column named `dup` that has a value of `TRUE` when the value of `n_row` is greater than 1 and `FALSE` otherwise.\n\nNotice that R only tags the second in a set of duplicate rows as a duplicate. Below we tag both rows with complete duplicate values.\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 √ó 4\n      id   day     x dup  \n   <dbl> <dbl> <dbl> <lgl>\n 1     1     1     1 FALSE\n 2     1     2    11 FALSE\n 3     2     1    12 FALSE\n 4     2     2    13 FALSE\n 5     2     2    14 FALSE\n 6     3     1    12 TRUE \n 7     3     1    12 TRUE \n 8     3     2    13 FALSE\n 9     4     1    13 FALSE\n10     5     1    10 TRUE \n11     5     2    11 FALSE\n12     5     1    10 TRUE \n```\n\n\n:::\n:::\n\n\n\n\n\n\n### Partial duplicate rows\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 √ó 3\n     id   day     x\n  <dbl> <dbl> <dbl>\n1     1     1     1\n2     1     2    11\n3     2     1    12\n4     2     2    13\n5     3     1    12\n6     3     2    13\n7     4     1    13\n8     5     1    10\n9     5     2    11\n```\n\n\n:::\n:::\n\n\n\n\n\n\nüëÜ**Here's what we did above:**\n\n* we used the `distinct()` function to keep only one row from a group of duplicate rows in the `df` data frame.\n\n* You can type `?distinct` into your R console to view the help documentation for this function and follow along with the explanation below.\n\n* This time we passed the column names `id` and `day` to the `...` argument. This tells R to consider any rows that have the same value of `id` _AND_ `day` to be duplicates -- even if they have different values in their other columns.\n\n* The `.keep_all` argument tells R to return all of the columns in `df` to us -- not just the columns that we are testing for uniqueness (i.e., `id` and `day`).\n\n### Partial duplicate rows - add tag\n\nwe can tag partial duplicate rows in a similar fashion to the way we tagged complete duplicate rows above: \n\n\n#| echo: false\n#| rows-print: 12\ndf %>% \n  group_by(id, day) %>% \n  mutate(\n    count = row_number(), # Counts rows by group\n    dup   = count > 1     # TRUE if there is more than one row per group\n  )",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}